["<p>I have been working on dynamic programming for some time. The canonical way to evaluate a dynamic programming recursion is by creating a table of all necessary values and filling it row by row. See for example <a href=\"http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&amp;tid=11866\" rel=\"nofollow noreferrer\">Cormen, Leiserson et al: \"Introduction to Algorithms\"</a> for an introduction.</p>&#xA;&#xA;<p>I focus on the table-based computation scheme in two dimensions (row-by-row filling) and investigate the structure of cell dependencies, i.e. which cells need to be done before another can be computed. We denote with $\\Gamma(\\mathbf{i})$ the set of indices of cells the cell $\\mathbf{i}$ depends on. Note that $\\Gamma$ needs to be cycle-free.</p>&#xA;&#xA;<p>I abstract from the actual function that is computed and concentrate on its recursive structure. Formally, I consider a recurrrence $d$ to be <em>dynamic programming</em> if it has the form</p>&#xA;&#xA;<p>$\\qquad d(\\mathbf{i}) = f(\\mathbf{i}, \\widetilde{\\Gamma}_d(\\mathbf{i}))$</p>&#xA;&#xA;<p>with $\\mathbf{i} \\in [0\\dots m] \\times [0\\dots n]$, $\\widetilde{\\Gamma}_d(\\mathbf{i}) = \\{(\\mathbf{j},d(\\mathbf{j})) \\mid \\mathbf{j} \\in \\Gamma_d(\\mathbf{i}) \\}$ and $f$ some (computable) function that does not use $d$ other than via $\\widetilde{\\Gamma}_d$.</p>&#xA;&#xA;<p>When restricting the granularity of $\\Gamma_d$ to rough areas (to the left, top-left, top, top-right, ... of the current cell) one observes that there are essentially three cases (up to symmetries and rotation) of valid dynamic programming recursions that inform how the table can be filled:</p>&#xA;&#xA;<p><img src=\"https://i.stack.imgur.com/AhnK7.png\" alt=\"Three cases of dynamic programming cell dependencies\"></p>&#xA;&#xA;<p>The red areas denote (overapproximations of) $\\Gamma$. Cases one and two admit subsets, case three is the worst case (up to index transformation). Note that it is not strictly required that the <em>whole</em> red areas are covered by $\\Gamma$; <em>some</em> cells in every red part of the table are sufficient to paint it red. White areas are explictly required to <em>not</em> contain any required cells.</p>&#xA;&#xA;<p>Examples for case one are <a href=\"https://en.wikipedia.org/wiki/Edit_distance\" rel=\"nofollow noreferrer\">edit distance</a> and <a href=\"https://en.wikipedia.org/wiki/Longest_common_subsequence_problem#Code_for_the_dynamic_programming_solution\" rel=\"nofollow noreferrer\">longest common subsequence</a>, case two applies to <a href=\"https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm\" rel=\"nofollow noreferrer\">Bellman &amp; Ford</a> and <a href=\"https://en.wikipedia.org/wiki/CYK\" rel=\"nofollow noreferrer\">CYK</a>. Less obvious examples include such that work on the diagonals rather than rows (or columns) as they can be rotated to fit the proposed cases; see <a href=\"https://cs.stackexchange.com/a/211/98\">Joe's answer</a> for an example.</p>&#xA;&#xA;<p>I have no (natural) example for case three, though! So my question is: What are examples for case three dynamic programming recursions/problems?</p>&#xA;", "<p>I have a \"smarter\" version of Bellman-Ford here; this version is more clever about choosing the edges to relax.</p>&#xA;&#xA;<pre><code>//Queue Q; source s; vertices u, v; distance to v d(v)&#xA;Q \u2190 s // Q holds vertices whose d(v) values have been updated recently.&#xA;While (Q !empty) {&#xA;  u \u2190 Dequeue(Q)&#xA;  for each neighbor v of u {&#xA;    Relax(u, v)&#xA;    if d(v) was updated by Relax and v not in Q&#xA;      Enqueue(v)&#xA;  }&#xA;}&#xA;</code></pre>&#xA;&#xA;<p>But, can anyone explain why this improved version correctly finds the shortest path from $s$ to every other vertex in a directed graph with no negative cycles?</p>&#xA;&#xA;<p>Also, what is the <em>worst-case</em> runtime if every shortest path uses at most $v$ edges?</p>&#xA;", "<p>We want to solve a minimal-cost-flow problem with a generic negative-cycle cancelling algorithm. That is, we start with a random valid flow, and then we do not pick any \"good\" negative cycles such as minimal average cost cycles, but use Bellman-Ford to discover a minimal cycle and augment along the discovered cycle. Let $V$ be the number of nodes in the graph, $A$ the number of edges, $U$ the maximal capacity of an edge in the graph, and $W$ the maximal costs of an edge in the graph. Then, my learning materials claim: </p>&#xA;&#xA;<ul>&#xA;<li>The maximal costs at the beginning can be no more than $AUW$ </li>&#xA;<li>The augmentation along one negative cycle reduces the costs by at least one unit </li>&#xA;<li>The lower bound for the minimal costs is 0, because we don't allow negative costs </li>&#xA;<li>Each negative cycle can be found in $O(VA)$ </li>&#xA;</ul>&#xA;&#xA;<p>And they follow from it that the algorithm's complexity is $O(V^2AUW)$. I understand the logic behind each of the claims, but think that the complexity is different. Specifically, the maximal number of augmentations is given by one unit of flow per augmentation, taking the costs from $AUW$ to zero, giving us a maximum of $AUW$ augmentations. We need to discover a negative cycle for each, so we multiply the maximal number of augmentations by the time needed to discover a cycle ($VA$) and arrive at $O(A^2VUW)$ for the algorithm. </p>&#xA;&#xA;<p>Could this be an error in the learning materials (this is a text provided by the professor, not a student's notes from the course), or is my logic wrong? </p>&#xA;", "<p>I've been studying the three and I'm stating my inferences from them below. Could someone tell me if I have understood them accurately enough or not? Thank you.</p>&#xA;&#xA;<ol>&#xA;<li><p><a href=\"https://en.wikipedia.org/wiki/Dijkstra_algorithm\" rel=\"noreferrer\">Dijkstra algorithm</a> is used only when you have a single source and you want to know the smallest path from one node to another, but fails in cases like <a href=\"https://i.stack.imgur.com/rmowk.png\" rel=\"noreferrer\">this</a>.</p></li>&#xA;<li><p><a href=\"https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm\" rel=\"noreferrer\">Floyd-Warshall algorithm</a> is used when any of all the nodes can be a source, so you want the shortest distance to reach any destination node from any source node. This only fails when there are negative cycles.</p></li>&#xA;<li><p><a href=\"https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm\" rel=\"noreferrer\">Bellman-Ford</a> is used like Dijkstra, when there is only one source. This can handle negative weights and its working is the same as Floyd-Warshall except for one source, right? (This is the one I am least sure about.)</p></li>&#xA;</ol>&#xA;", "<p>The <a href=\"http://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm\">Bellman-Ford algorithm</a> determines the shortest path from a source $s$ to all other vertices. Initially the distance between $s$ and all other vertices is set to $\\infty$. Then the shortest path from $s$ to each vertex is computed; this goes on for  $|V|-1$ iterations. My questions are:</p>&#xA;&#xA;<ul>&#xA;<li>Why does there need to be $|V|-1$ iterations?</li>&#xA;<li>Would it matter if I checked the edges in a different order?<br>&#xA;Say, if I first check edges 1,2,3, but then on the second iteration I check 2,3,1. </li>&#xA;</ul>&#xA;&#xA;<p>MIT  Prof. Eric said the order didn't matter, but this confuses me: wouldn't the algorithm incorrectly update a node based on edge $x_2$ if its value was dependent on the edge $x_1$ but $x_1$ is updated after $x_2$?</p>&#xA;", "<p>I have to find a negative cycle in a directed weighted graph. I know how the Bellman Ford algorithm works, and that it tells me if there is a reachable negative cycle. But it does not explicitly name it.</p>&#xA;<p>How can I get the actual path <span class=\"math-container\">$v1, v2, \\ldots vk, v1$</span> of the cycle?</p>&#xA;<p>After applying the standard algorithm we already did <span class=\"math-container\">$n-1$</span> iterations and no further improvement should be possible. If we can still lower the distance to a node, a negative cycle exists.</p>&#xA;<p>My idea is: Since we know the edge that can still improve the path and we know the predecessor of each node, we can trace our way back from that edge until we meet it again. Now we should have our cycle.</p>&#xA;<p>Sadly, I did not find any paper that tells me if this is correct. So, does it actually work like that?</p>&#xA;<p><strong>Edit:</strong> This example proofs that my idea is wrong.&#xA;Given the following graph, we run Bellman-Ford from node <span class=\"math-container\">$1$</span>.</p>&#xA;<p><img src=\"https://i.stack.imgur.com/pNLTw.png\" alt=\"enter image description here\" /></p>&#xA;<p>We process edges in the order <span class=\"math-container\">$a, b, c, d$</span>. After <span class=\"math-container\">$n-1$</span> iterations we get <strong>node distances:</strong><br>&#xA;<span class=\"math-container\">$1: -5$</span><br>&#xA;<span class=\"math-container\">$2: -30$</span><br>&#xA;<span class=\"math-container\">$3: -15$</span></p>&#xA;<p>and <strong>parent table:</strong><br>&#xA;<span class=\"math-container\">$1$</span> has parent <span class=\"math-container\">$3$</span><br>&#xA;<span class=\"math-container\">$2$</span> has parent <span class=\"math-container\">$3$</span><br>&#xA;<span class=\"math-container\">$3$</span> has parent <span class=\"math-container\">$2$</span><br></p>&#xA;<p>Now, doing the <span class=\"math-container\">$n$</span>th iteration we see that the distance of node <span class=\"math-container\">$1$</span> can still be improved using edge <span class=\"math-container\">$a$</span>. So we know that a negative cycle exists and <span class=\"math-container\">$a$</span> is part of it.</p>&#xA;<p>But, by tracing our way back through the parent table, we get stuck in another negative cycle <span class=\"math-container\">$c, d$</span> and never meet <span class=\"math-container\">$a$</span> again.</p>&#xA;<p>How can we solve this problem?</p>&#xA;", "<p>I'm studying shortest paths in directed graphs currently. There are many efficient algorithms for finding the shortest path in a network, like dijkstra's or bellman-ford's. But what if the graph is dynamic? By saying dynamic I mean that we can insert or remove vertices during the execution of the program. I'm trying to find an efficient algorithm for updating the shortest paths from a vertex $v$ to every other vertex $u$, after inserting an edge $e$, without needing to run the shortest path algorithm in the new graph again. How can I do this? Thanks in advance.</p>&#xA;&#xA;<ul>&#xA;<li><em>Note:</em> the changes can be done after the first iteration of the algorithm</li>&#xA;<li><em>Note[2]:</em> two nodes are given, $s$ the source and $t$ the target. I need to find the shortest path between these nodes. When the graph is updated I only have to update $\\pi(s,t)$, which is the shortest path between $s$ and $t$.</li>&#xA;<li><em>Note[3]:</em> I'm only interested in the edge insertion case.</li>&#xA;</ul>&#xA;&#xA;<blockquote>&#xA;  <p><strong>A formal definition</strong>: Given a graph $G = (V,E)$. Define an <em>update operation</em> as 1) an insertion of an edge $e$ to $E$ or 2) a a deletion of an edge $e$ from $E$. The objective is to find efficiently the cost of all pairs shortest paths after an update operation. By efficiently, we mean at least better than executing an All-Pairs-Shortest-Path algorithm, such as Bellman-Ford algorithm, after each update operation.</p>&#xA;</blockquote>&#xA;&#xA;<hr>&#xA;&#xA;<p><strong>Edit:</strong> Below there is a simplified version of the problem:</p>&#xA;&#xA;<blockquote>&#xA;  <p>A weighted graph $G(V,E)$ is given, consisting of unidirectional edges, and two critical vertices $s$ and $t$. A set $C$ of candidate <em>bidirectional</em> edges is also given. I have to build an edge $(u,v) \\in C$ to minimize the distance from $s$ to $t$.</p>&#xA;</blockquote>&#xA;", "<p>I  found the algorithm for finding the negative cycle in a graph after running <a href=\"http://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm\" rel=\"nofollow\">Bellman-Ford algorithm</a>.</p>&#xA;&#xA;<p>The algorithm is to perform another relax iteration over all the edges. Than if we find an edge to relax we stop and start to follow it parent vertex starting from $V$ that $u$ is its parent until we close a cycle.</p>&#xA;&#xA;<p>I'm having little problem proving this. I want to prove now that no matter when I stop the algorithm - if $p[v] = u$ always $d[v]\\le d[u]+w(u,v)$ and to prove that a cycle in parent pointer is necessarily a negative cycle.</p>&#xA;", "<p>First of all, let me preface by saying that this question is not completly new but the original question hasn't been answered. More important, this is only basic question on understanding the proof itself.</p>&#xA;&#xA;<p>So after some search in the site I found the following question : <a href=\"https://cs.stackexchange.com/questions/7565/bellman-ford-algorthm-and-negative-cycle-proof\">Bellman-Ford algorthm and negative cycle proof</a>.</p>&#xA;&#xA;<p>The guy is trying to understand how to prove <em>that a cycle in parent pointer is necessarily a negative cycle</em>.</p>&#xA;&#xA;<p>My question is very basic and isn't duplicate, I just couldn't find anything in the document on the related question which answers my question.</p>&#xA;&#xA;<p>What does it mean a cycle in the parent pointer? I mean I could a graph whereas the cycle in the parent pointer isn't a negative cycle... I don't understand why It must be a negative cycle.</p>&#xA;&#xA;<p>See an example of a graph I have in mind :</p>&#xA;&#xA;<p><img src=\"https://i.stack.imgur.com/DSlY3.jpg\" alt=\"enter image description here\"></p>&#xA;&#xA;<p>Now suppose the first node we start with is (a) and suppose the we travling the edges in the following order: ab,bc,cd.</p>&#xA;&#xA;<p>and here we goes, we have a cycle in the parent pointer, and as far as I understand that is (c) becuase it is the parent of (d) and yet the cycle isn't negative cycle.</p>&#xA;", "<p>I am trying to solve a system of inequalities in the following form:&#xA;$\\ x_i - x_j \\leq w $</p>&#xA;&#xA;<p>I know these inequalities can be solved using <code>Bellman-Ford</code> algorithm. But there is also another condition. I want to find the solution that maximizes $\\ x_n - x_1$</p>&#xA;&#xA;<p>As far as I know the default <code>Bellman-Ford</code> algorithm minimizes it. How do I do that?</p>&#xA;", "<p>Let $G = (V,E)$ be a directed graph  with a weight function $w$ such that there are no negative-weight cycles, and let $v \\in V$ be a vertex such that there is a path from $v$ to every other vertex. Let $f : V \\to \\mathbb R$ be a given function. Describe an algorithm that runs in $O(|V| + |E|)$ time that answers yes/no to the question: is it true that for all $u \\in V, f(u) = \\delta(v,u)$, where $\\delta(v,u)$ is the weight of the shortest path from $v$ to $u$?</p>&#xA;&#xA;<p>Obviously what comes to mind is Bellman-Ford algorithm, but it doesn't satisfy the time requirement. I don't really see how having the candidate $f$ function helps us in this regard.</p>&#xA;", "<p>I wrote a program which implements Bellman-Ford, and identifies when negative weight cycles are present in a graph. However what I'm actually interested in, is given some starting vertex and a graph, which path do I actually trace to get to the original vertex having traveled a negative amount. </p>&#xA;&#xA;<p>So to be clear say I have a graph with vertexes, a, b, c, and d and there is a negative cycle between a, b, and d, then when I check for negative weight cycles </p>&#xA;&#xA;<pre><code>// Step 1: initialize graph&#xA;   for each vertex v in vertices:&#xA;       if v is source then distance[v] := 0&#xA;       else distance[v] := infinity&#xA;       predecessor[v] := null&#xA;&#xA;   // Step 2: relax edges repeatedly&#xA;   for i from 1 to size(vertices)-1:&#xA;       for each edge (u, v) with weight w in edges:&#xA;           if distance[u] + w &lt; distance[v]:&#xA;               distance[v] := distance[u] + w&#xA;               predecessor[v] := u&#xA;&#xA;   // Step 3: check for negative-weight cycles&#xA;   for each edge (u, v) with weight w in edges:&#xA;       if distance[u] + w &lt; distance[v]:&#xA;           \"Graph contains a negative-weight cycle\"&#xA;</code></pre>&#xA;&#xA;<p>Instead of it just telling me that a negative cycle is there, I would like it to tell me, go from <code>a -&gt; b -&gt; d -&gt; a</code>.  After the relaxing step what do I have to change in my check for negative weight cycles to get it to output this information? </p>&#xA;&#xA;<ul>&#xA;<li><p><a href=\"http://blog.alirabiee.com/?p=576\" rel=\"nofollow noreferrer\">Here</a> is the best information I've been able to find, but I'm still having trouble making sense of it.  </p></li>&#xA;<li><p>Also <a href=\"http://www.cs.ucdavis.edu/~amenta/f05/hw5.pdf\" rel=\"nofollow noreferrer\">this</a> which suggests that I need to run breadth first search on the predecessor array to find the information, but I'm not exactly sure where to start (what do I queue first?) </p></li>&#xA;<li><p><a href=\"https://stackoverflow.com/questions/2282427/interesting-problem-currency-arbitrage\">Here</a> is a stack overflow question which shows how to find one of the nodes in the path.</p></li>&#xA;</ul>&#xA;", "<p>Given a weighted digraph, I can check whether a given vertex belongs to a negative cycle in $O(|V|\\cdot|E|)$ using Bellman-Ford. But what if I need to find all vertices on negative cycles? Is there a way to do it faster than Floyd-Warshall's $O(|V|^3)$?</p>&#xA;", "<p>I need your help with an exercise on <a href=\"http://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm\" rel=\"noreferrer\">Ford-Fulkerson</a>.</p>&#xA;<blockquote>&#xA;<p>Suppose you are given a flow network with capacities <span class=\"math-container\">$(G,s,t)$</span> and you are also given the max flow <span class=\"math-container\">$|f|$</span> in advance.</p>&#xA;<p>Now suppose you are given an arc <span class=\"math-container\">$e$</span> in <span class=\"math-container\">$G$</span> and suppose this arc's capacity is increased by one.</p>&#xA;<p>Give an efficent algorithm which returns true iff the increase of the capacity of the arc <span class=\"math-container\">$e$</span> will allow an increase in the max flow.</p>&#xA;</blockquote>&#xA;<p>I suppose we shouldn't run Ford-Fulkerson again but somehow use the given <span class=\"math-container\">$|f|$</span>\u2026 Any ideas how?</p>&#xA;", "<p>I have a directed graph with $N$ vertices. Every pair of vertices is connected by two edges (one in each direction), and each of these edges has a weight which may be negative.</p>&#xA;&#xA;<p>On various occasions 'edge update' operations occur, where the weight of an edge is modified (although the edge is never deleted, and no new edges or vertices are added). After each of these operations I wish to know the length of the shortest path between one 'root' vertex and every other vertex in the graph. I don't care what the path is, and I already know it must exist. I don't mind how negative weight cycles are handled.</p>&#xA;&#xA;<p>I care about optimizing the running time of the single update operation and the $N$ queries that follow.</p>&#xA;&#xA;<p>The obvious approach would be Bellman-Ford, which would take $O(|V||E|)$ which is $O(n^3)$.</p>&#xA;&#xA;<p>Is there a faster way to do it?</p>&#xA;", "<p>I have to find an algorithm that finds the SSSP (single-source shortest path - shortest paths from one source vertex to all other vertices) on a weighted undirected graph. If there are 2 different shortest paths, the algorithm should prefer the one with less edges on it. The time complexity of the algorithm is $O((|V|+|E|) \\log |V|)$.</p>&#xA;&#xA;<p>So, I tried:</p>&#xA;&#xA;<ul>&#xA;<li>My first thought was DFS/BFS (the $O(|V|+|E|)$ looks tempting), but (I believe) no modification of these two algorithms works on weighed graphs.</li>&#xA;<li>Then I thought about Dijkstra's algorithm - but that one doesn't work on graphs, which can have negative edges.</li>&#xA;<li>My last hope was Bellman-Ford algorithm, which could work I guess, but I have no idea, how to rewrite it for undirected graphs.</li>&#xA;</ul>&#xA;&#xA;<p>Any hint is appreciated.</p>&#xA;", "<p>I'm trying to design an algorithm for the following optimization problem. Suppose that $G=(V, E)$ is a digraph where $V$ and $E$ are sets of vertices and edges of $G$, respectively. $|V| = n$ and $|E| = m$. $c$ is the cost vector; $c_{ij}$ is the cost of edge $(i,j)$. Costs <strong>can</strong> be negative and $G$ <strong>may</strong> have cycles (negative or positive). <strong>The target</strong> is a minimum cost flow from source vertex $1$ to sink vertex $n$ which must satisfy some constraints. So let $x$ be the solution vector; if $x_{ij}=1$ then the edge $(i,j)$ is a part of minimum cost flow. Here is my optimization problem:</p>&#xA;&#xA;<p>$$min \\sum_{(i,j)\\in E}c_{ij}x_{ij}$$</p>&#xA;&#xA;<p>Subject to these constraints:</p>&#xA;&#xA;<p>$$\\begin{array}{ll}&#xA;\\sum_{i\\in V}x_{ij}&amp;=&amp;\\sum_{i\\in V}x_{ji}~~~~~~\\forall j\\in V (j\\neq1,n)\\\\&#xA;\\sum_{j\\in V}x_{1j}&amp;=&amp;1\\\\&#xA;\\sum_{i\\in V}x_{in}&amp;=&amp;1\\\\&#xA;x_{ij}&amp;\\in&amp;\\{0,1\\}~~~~~~\\forall i,j\\in V\\end{array}$$</p>&#xA;&#xA;<p><strong>First constraint</strong> makes us sure that in the final solution vector, total number of edges outgoing from vertex $i$ and total number of edges incoming to that vertex are equal.</p>&#xA;&#xA;<p>Only one edge can go out from vertex $1$, based on <strong>second constraint</strong> and only one edge can come to vertex $n$, based on <strong>third constraint</strong>.</p>&#xA;&#xA;<p>Finally, <strong>last constraint</strong> tells us that the maximum flow allowed for each edge is $1$.</p>&#xA;&#xA;<p>This is the problem of sending <strong>a flow of value one</strong> from vertex $1$ to vertex $n$  subject to the constraints with a capacity limit of $1$ on each edge and the vector $b$ set to $0$.</p>&#xA;&#xA;<p><strong>I asked this question because</strong> I think a flow in this case can be viewed as a path, in which we can goes around it's cycles (if any cycle exists on the path) only once and it can't meet vertices $1$ and $n$ more than once. So, can we solve this problem using a modified version of <a href=\"http://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm\" rel=\"nofollow\">Bellman-Ford</a> or any other dynamic programming algorithm? Time order isn't the matter to me. I just don't want to use algorithms designed for the general form of minimum cost flow problem.</p>&#xA;", "<p>I have a homework question which I would appreciate some help with:</p>&#xA;<blockquote>&#xA;<p>Let there be a DAG <span class=\"math-container\">$G=(V,E)$</span> with positive weights. For every two different vertices <span class=\"math-container\">$v_1, v_2$</span> we will define <span class=\"math-container\">$D(v_1, v_2)$</span> to be the maximum length between <span class=\"math-container\">$v_1$</span> and <span class=\"math-container\">$v_2$</span> in the graph.</p>&#xA;<p>For every two disjoint sub-sets of vertices <span class=\"math-container\">$V_1, V_2 \\subset V$</span> we will define &quot;The detour length&quot; between them to be: <span class=\"math-container\">$w(V_1, V_2) = max\\{D(v_1, v_2) \\mid v_1\\in V_1, v_2 \\in V_2\\}$</span></p>&#xA;<p>Describe an algorithm which runs at <span class=\"math-container\">$O(|V|\\cdot |E|)$</span> complexity, that receives as an input <span class=\"math-container\">$V_1, V_2 \\subset V$</span> and calculates <span class=\"math-container\">$w(V_1, V_2)$</span></p>&#xA;<p>(Hint: You can add vertices and edges to the graph)</p>&#xA;</blockquote>&#xA;<p>OK so I realize that this is a problem which is connected to finding the longest path in a DAG. I know that I can negate all the weights inside <span class=\"math-container\">$G$</span> and run Bellman-Ford to find the longest path, (It will work without issues because this is a DAG). Because Bellman-Ford runs in the wanted complexity, I think this can be solved by doing some modification to B-F, but I can't seem to figure out what I can do to solve it.</p>&#xA;<p>Every solution I come up with will run in a higher complexity than needed - I thought about running B-F on every vertex on <span class=\"math-container\">$V_1$</span> and then calculating the max, but this isn't efficient, and also doesn't really use the hint. I also though about creating a second graph by connecting the two sub-sets but that also will run at a higher complexity because I need to run over every vertex.</p>&#xA;<p>Any help is appreciated, Thx!</p>&#xA;", "<p>Let $s$ be the source vertex. In the standard Bellman-Ford algorithm (e.g. the version found in CLRS), when there is a negative cycle reachable form $s$, the algorithm will return that a negative cycle is found. </p>&#xA;&#xA;<p>But let's say I am interested in the shortest path from $s$ to some vertex $a$, and it might be that there is a negative cycle reachable from $s$, but it could also be that no such negative cycles have a path to $a$. So technically there is still a shortest path from $s$ to $a$. But Bellman-Ford would still say \"negative cycle detected\" although it is irrelevant! How might Bellman-Ford be modified to still spit out either the shortest path or that there is no shortest path?</p>&#xA;&#xA;<p><strong>Attempt:</strong> At first I saw thinking of running Bellman-Ford until $2n$ (or some large number) and then seeing if the value for $s$ to $a$ stays stable, but I found an example that invalidates this. It appears that I must find all negative cycles reachable from $s$ and check if each of them can reach $a$. That seems like an immense amount of work! So is there any clever way to do this?</p>&#xA;", "<p>I was trying to find all the negative cycle vertices using the Bellman&ndash;Ford algorithm using <a href=\"http://courses.csail.mit.edu/6.046/spring04/handouts/ps7sol.pdf\" rel=\"nofollow noreferrer\">this paper solution 7.1(b)</a> in $O(V)$ by tracing back the predecessor subgraph.It is also stated in <a href=\"https://cs.stackexchange.com/questions/6919/getting-negative-cycle-using-bellman-ford\">this answer</a> too. But then while googling I found another <a href=\"https://stackoverflow.com/questions/16720689/finding-all-vertices-on-negative-cycles\">Stack Overflow question</a> it is proved that finding negative cycle vertices are NP complete. So what is it actually?</p>&#xA;", "<p>Problem statement: Given a graph G(V,E) which is not acyclic and may have negative edge weights (and thus may possibly have negative-length cycles), how does one detect if the graph has a zero-length cycle, and no negative-length cycles?</p>&#xA;&#xA;<p>Background information: The question came up when I tried to implement in code the solution to what is called the \"tramp steamer\" problem: Given a graph G(V,E) in which each node is associated with a cost $c_i$ and each edge is associated with a time (number of days) $t_i$, find the cycle with the smallest ratio of cost to time $\\frac{\\sum_i(c_i)}{\\sum_i(t_i)}$ (i.e. minimal cost/day cycle).</p>&#xA;&#xA;<p>One solution is to do a binary search with the range of possible rations, trying to identify the minimum cost-to-time ratio $\\mu$. In each iteration of the binary search in the range $[left...right]$, you \"guess\" a value of $\\mu = \\frac{left+right}{2}$ and then run Bellman-Ford:</p>&#xA;&#xA;<ul>&#xA;<li>if a negative cycle exists then the value of $\\mu$ is too high; the range is reset to $[left...\\mu]$</li>&#xA;<li>if all cycles are positive then the value of $\\mu$ is too low; the range is reset to $[\\mu...right]$</li>&#xA;<li>if there is a zero-length cycle (with all other cycles being positive), then we have found the best value for $\\mu$ and we can stop, returning the zero-length cycle as the answer</li>&#xA;</ul>&#xA;&#xA;<p>How exactly is the third case detected? Assume the graph A->B->C->D->{A,B}  with two cycles (fro D back to A or B) where the cycle B->C->D->B is the optimal one and yields zero length for some selection of $\\mu$ for which the other cycle is positive. Suppose we happen to try this particular value of $\\mu$ (let's assume it's during the very first iteration because we got lucky). If I am using vertex A as the fixed point from which I run Bellman-Ford on each iteration, it will complete successfully without detecting a negative cycle. But how would the zero-length cycle be identified?</p>&#xA;&#xA;<p>Currently I only handle the first 2 cases and my implementation keeps iterating until the $[left...right]$ range becomes becomes too small, so that floating point precision can't handle a smaller range. At that point I detect that $\\frac{left+right}{2}$ is equal to one of the range limits (either left or right) and stop the binary search. How would I go about detecting that a particular value of $\\mu$ has produced a zero-length cycle?</p>&#xA;", "<p>(Please note, this is not a duplicate to <a href=\"https://cs.stackexchange.com/questions/11503/shortest-path-with-exactly-k-edges\">Shortest path with exactly $k$ edges</a>  OR  <a href=\"https://stackoverflow.com/questions/1690347/shortest-path-with-a-fixed-number-of-edges\">Shortest path with a fixed number of edges</a>. What I want is a better algorithm)</p>&#xA;&#xA;<p>The problem under consideration is to find single-source-shortest-path of at most $k$-edges (simple paths only). What we have is very special case: a Directed Acyclic Graph (DAG) $~G(V,E)~$ with positive edge weights.</p>&#xA;&#xA;<blockquote>&#xA;  <p>A preliminary solution to the problem is to run Bellman-Ford to $k$-iterations with <strong>parallel relaxation</strong> on all edges.</p>&#xA;</blockquote>&#xA;&#xA;<p>Bellman-Ford solution for finding usual shortest-paths, is generally known to be worse in complexity for graphs with positive edge weights. But it is the only algorithm, which possesses the very special property of identifying all $k$-edge optimal paths after $k$-iterations, provided we relax the edges parallelly. This eventually finds all shortest simple paths after at most $|V|-1$ iterations.</p>&#xA;&#xA;<p>So simply by stopping the Bellman-Ford algorithm after $k$ iterations, we can find the desired shortest-path of at most $k$-edges from the given source. Also note that, Bellman-Ford algorithm is a classic instance of Dynamic Programming(DP) and the truncated version proposed above is a DP as well.</p>&#xA;&#xA;<p>It seems dynamic-programming/Bellman-Ford algorithm (truncated to k-iterations &amp; parallel relaxing of edges) will solve this problem with $O(k|E|)$ complexity. But can we do better at least on a graph with non-negative weights? At least, for a Directed Acyclic Graph(DAG) with non-negative weights!</p>&#xA;&#xA;<p>I think it is a legitimate question to ask for a better algorithm, given that we have a much better alternative for usual shortest-path algorithms on graphs with positive weights, namely the Dijkstra's algorithm. Interesting question here is this: Does it extend to finding $k$-edge optimal paths?  This is definitely not immediate, since unlike Bellman-Ford, Dijkstra's doesn't have this property of $k$-edge optimality at $any$ iteration.</p>&#xA;&#xA;<p>(Worse thing is that even the constant-factor saving modifications to Bellman-Ford, proposed by Yen, are no more useful for truncated Bellman-Ford.&#xA;I have a strong hope to have something better!)</p>&#xA;", "<p><a href=\"https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\" rel=\"nofollow\">Dijkstra's algorithm (wiki)</a> and <a href=\"https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm\" rel=\"nofollow\">Bellman-Ford (wiki)</a> algorithm are two typical algorithms for the single-source <a href=\"https://en.wikipedia.org/wiki/Shortest_path_problem\" rel=\"nofollow\">shortest path problem</a>. Both of them compute distances for all nodes from source $s$. </p>&#xA;&#xA;<blockquote>&#xA;  <p>If both source $s$ and destination $t$ are fixed, can we compute the shortest path from $s$ to $t$ <strong>without</strong> computing distances for all other nodes from $s$?</p>&#xA;</blockquote>&#xA;&#xA;<p>More fundamentally, </p>&#xA;&#xA;<blockquote>&#xA;  <p>Is single-source single-destination shortest path problem easier (e.g., in terms of worst-case time complexity) than its single-source all-destination counterpart?</p>&#xA;</blockquote>&#xA;", "<p>I'm doing a min cost assignation problem to assign doctors to their working days for a hospital.</p>&#xA;&#xA;<p>After correctly getting the max flow with Ford-Fulkerson algorithm, I would like to use the cycle canceling algorithm to minimze the flow's cost. I'm basically using the Bellman-Ford algorithm from the sink of the residual graph with the max flow. </p>&#xA;&#xA;<p>The problem is that Bellman-Ford gives me one negative weight cycle (the one that reduces more the cost), and in a given example, such cycle has a bottleneck capacity of 0, so I cannot send flow around it. However in the very same example, other negative weight cycles exist with a bottleneck capacity strictly greater than 0. Sending the bottleneck flow among these cycles would certainly reduce the cost of my assignment, nevertheless the Bellman-Ford implementation does not seem to be capable of yielding such cycles.</p>&#xA;&#xA;<p>How might I get <em>all the graph's negative cycles</em>, to finally get the min cost assignation?</p>&#xA;&#xA;<p>For this university project, the algorithm's performance is not relevant.</p>&#xA;", "<p>In the Bellman&ndash;Ford algorithm, what is the practical meaning of&#xA;having a negative path between routers?&#xA;I have tried searching the net but didn't find any data</p>&#xA;&#xA;<p>thanks&#xA;Eli  </p>&#xA;", "<p>Let $A$ be a set of $n$ closed intervals, $I_i$, with both extremes positive integers. Is there an efficient algorithm to find a set of $n$ points $P_i$, with $P_i \\in I_i$, such that the minimum distance between all pairs of points is maximized?</p>&#xA;&#xA;<p>Assume that the intervals are bounded by a positive integer $C$.</p>&#xA;&#xA;<p>What's the complexity of this problem?</p>&#xA;&#xA;<p>If the intervals are non-overlapping, I know how to solve this with linear programming (indeed, using a system of difference constraints and Bellman-Ford), but what can we say about the general case where intervals might overlap?</p>&#xA;&#xA;<p><strong>Note:</strong> Most comments/answers so far are looking for a polynomial solution. Note that it is possible that this problem is NP-complete. I know that it was  the style of this teacher to include problems for which students had to prove NP-completeness.</p>&#xA;", "<p>I want an algorithm similar to Dijkstra or Bellman-Ford for finding the shortest path between two nodes in a directed graph, but with an additional constraint. </p>&#xA;&#xA;<p>The additional constraint is that there are $N$ sets of special edges with weight $0$ such that a path is not considered valid if it traverses one edge in a set but not the remaining edges in that set.</p>&#xA;&#xA;<p>Note that these $N$ sets of edges are disjoint such that no edge belongs to more than one of the $N$ sets. The number of edges in each set is around 3 to 6. And there are a large number of these sets. About $50\\%$ of edges belong to a set, the rest don't belong to a set and can be traversed normally.</p>&#xA;&#xA;<p>Does such an algorithm exist? Can such an algorithm exist that is better than brute force?</p>&#xA;", "<p>Given a directed graph, Dijkstra or Bellman-Ford can tell you the shortest path between two nodes.</p>&#xA;&#xA;<p>What if there are two (or n) paths that are shortest, is there an algorithm that will tell you all such paths?</p>&#xA;&#xA;<p>Edit:</p>&#xA;&#xA;<p>I have just thought up a possible solution. Could you just do a Bellman-Ford but when relaxing edges, if (distance[u] + w == distance[v]) then add u to the <strong>set</strong> of predecessors of v? Does this work?</p>&#xA;", "<p>I have the following homework exercise:</p>&#xA;&#xA;<blockquote>&#xA;  <p>We are given a network $N=(G,w,d)$, $G=(V,E)$ together with a designated&#xA;  source node s\u2208V and target node $t \\in V$, where $w\\colon E \\to Z^+$ and $d\\colon E \\to Z^+$. The&#xA;  values $w_{i,j}$ correspond to arc weights, $d_{i,j}$ correspond to delays,&#xA;  i.e., using the arc $(i,j)$ requires $d_{i,j}$ time. We are further given a&#xA;  positive number $D \\in N$, the delay constraint. Develop an efficient, i.e.,&#xA;  $O(D \\cdot |E|)$, algorithm to find a shortest path $P$ from some $s$ to $t$, which&#xA;  does not exceed the global delay constraint $D$, i.e., $\\sum_{(i,j) \\in P} d_{i,j}\u2264D$ (Hint: use a similar approach as the one used in the Bellman&#xA;  Ford algorithm).</p>&#xA;</blockquote>&#xA;&#xA;<p>I was able to find an algorithm that runs in $O(D \\cdot |E| \\cdot |V|)$ time. However I'm struggling with finding an algorithm that runs in $O(D \\cdot |E|)$ time and I'm starting to think, that such algorithm is not even possible to create (although I don't have a formal proof for this).</p>&#xA;&#xA;<p>Could you give me a clue how would such an algorithm look like?</p>&#xA;", "<p>I'm a little confused about the concept of the Bellman-Ford(BF) algorithm to compute the shortest path in a general graph with negative weights knowing that there are no negative cycles present. I understand why Dikjstra doesn't work for a graph with negative weights. So in the Bellman-Ford algorithm we decide to update all nodes and their neighbors even though they might be visited before. My confusion can be summarized in a couple of questions:</p>&#xA;&#xA;<ol>&#xA;<li><p>Why running the BF algorithm once won't make sure that all nodes' distances have the minimum distance from the source?</p></li>&#xA;<li><p>Why do we have to run BF for N-1 (N: number of nodes) times to make sure all the nodes have the minimum distance from the source? Is it sort of because there are negative weights? How negative weights complicate things?</p></li>&#xA;</ol>&#xA;", "<p>How to find the longest (in terms of sum of weights) simple path with at most $k$ edges in a tree? Weights of edges are integers, so they can be negative. I thought about using Bellman-Ford, but it would take too much time. Is there any faster algorithm than $O(V \\cdot E)$?</p>&#xA;", "<p>Consider Ford\u2013Fulkerson algorithm (FF). </p>&#xA;&#xA;<p>Look to <a href=\"https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm\" rel=\"nofollow\">wiki</a> : </p>&#xA;&#xA;<blockquote>&#xA;  <p>The following example shows the first steps of Ford\u2013Fulkerson in a flow network with 4 nodes, source A and sink D. This example shows the worst-case behaviour of the algorithm. In each step, only a flow of 1 is sent across the network. If breadth-first-search were used instead, only two steps would be needed.</p>&#xA;</blockquote>&#xA;&#xA;<p>In practice this example does not work, because each vertex has fixed (determenistic) order of outgoing edges.</p>&#xA;&#xA;<p>We've introduced simple test for \"determenistic order of edges\" with number of pathes $2^{n/4}$. </p>&#xA;&#xA;<p>At beggining of FF you may shuffle all the edges. After it during the algorithm the order of the edges is immutable. The optimization breaks our simple test with $2^{n/4}$ pathes, but there is another test with subexponential number of pathes: $2^{n/(8logn)}$. More precisely: probability that \"number of pathes is $2^{n/(8logn)}$\" over all $m!$ shuffles of $m$ edges seeks to $1$ with $n$ seeks to $\\infty$. </p>&#xA;&#xA;<p>Look more to wiki: </p>&#xA;&#xA;<blockquote>&#xA;  <p>Non-terminating example</p>&#xA;</blockquote>&#xA;&#xA;<p>If you use dfs with deterministic order of edges (as in practice!) then FF always terminates. Even for graphs with real capacities of edges.</p>&#xA;&#xA;<p>Our question. &#xA;Do you know papers, books, lection notes, which contain such tests and the proof of the proposition \"FF, implemented via dfs, always terminates\"?</p>&#xA;", "<p>I am aware of using Bellman-Ford on a graph $G=(V,E)$ with no negative cycles to find the single-source single-destination shortest paths from source $s$ to target $t$ (both in $V$) using at most $k$ edges. Assuming we have no negative edge weights at all, can we use Dijkstra's algorithm for the same? </p>&#xA;&#xA;<p><strong>My thoughts/algorithm:</strong>&#xA;I was wondering if instead of having a $dist[u$] array (storing the best known distance from s to u), we could use a $dist[u][k]$ table to store the best known distance from $s$ to $u$ using at most $k$ edges (dynamic programming maybe?), and similarly have the priority queue with $(u,n)$ tuples as keys. We can then terminate the algorithm when the tuple popped off the priority queue is $(t,n)$ where t is the target destination and $n &lt;= k$?</p>&#xA;", "<p>Given a weighted digraph with positive and negative edge weights, what is the complexity of finding the negative cycle in the graph whose weight is as small as possible?</p>&#xA;&#xA;<p>I know that I can detect negative weight cycles using Bellman-Ford. Has this variation be studied before? Can you point me to a reference?</p>&#xA;", "<p>Given a weighted digraph with positive and negative edge weights, what is the complexity of finding the shortest (uses the least number of edges) negative weight cycle in the graph?</p>&#xA;&#xA;<p>I know that I can detect negative weight cycles using Bellman-Ford. Has this variation be studied before? Can you point me to a reference?</p>&#xA;", "<p>Given a weighted complete bipartite directed graph K_{m,n}, is it possible to find a simple cycle (every node is visited at most a single time) with minimal weight in polynomial time (in m*n) when there exist simple cycles with negative weight? </p>&#xA;&#xA;<p>For general graphs this problem is NP-complete (<a href=\"https://cs.stackexchange.com/questions/54829/finding-the-lowest-weight-negative-cycle-in-a-weighted-digraph\">Finding the lowest-weight negative cycle in a weighted digraph</a>). Using Bellman-Ford it is possible to find a cycle with negative weight if such a cycle exists, but this algorithm gives no guarantee that it is the most negative cycle.</p>&#xA;&#xA;<p>In total there are&#xA;<a href=\"https://i.stack.imgur.com/6ePqA.gif\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/6ePqA.gif\" alt=\"enter image description here\"></a></p>&#xA;&#xA;<p>simple cycles in this graph, so checking all of them would already give a subexponential algorithm. But can this be reduced to a polynomial time algorithm?</p>&#xA;&#xA;<p>Some assumptions I can make:</p>&#xA;&#xA;<ul>&#xA;<li>The absolute value of the weights are bounded by a constant C.</li>&#xA;<li>There exists a negative simple cycle and all negative simple cycles visit at least 4 nodes.</li>&#xA;</ul>&#xA;&#xA;<p>Thanks.</p>&#xA;", "<p>I am looking for the longest simple path in a directed, cyclic and weighted graph with positive and negative weights.</p>&#xA;&#xA;<p>In my research so far I have found out that you need to generate <code>-G</code> from graph <code>G</code> and then run a shortest path algorithm on it to find the longest path in <code>G</code>. Of course this won't work if <code>-G</code> contains negative cycles. But that's excatly what I need to do. Consider following graph (which I created quickly in paint..):</p>&#xA;&#xA;<p><a href=\"https://i.stack.imgur.com/74vDp.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/74vDp.png\" alt=\"enter image description here\"></a></p>&#xA;&#xA;<p>The red letters are just there for identification. The red numbers are the value of the vertex and the blue numbers are the edge weights. &#xA;The edge weights are generated with the following formula: </p>&#xA;&#xA;<p>$$ Weight = \\frac{destination}{source} $$</p>&#xA;&#xA;<p>I am looking for the longest path from <code>A</code> to <code>F</code> - but the longest <strong>simple</strong> path. That means that a vertex must not be visited more than once. By simply looking at it I can see that it is <code>A - B - E - F</code>. But if I tried to generate <code>-G</code> and then run the Bellman-Ford algorithm on it it would fail because there would be negative cycles like <code>B - E - D - B</code>. </p>&#xA;&#xA;<p>I am aware that it is not possible if you look for paths in which a vertex can be visited more than once. But if you look for simple paths only, is it still not possible? </p>&#xA;", "<p>I am reading on how solving maximum flow (Ford-Fulkerson) can be also used to solve unweighted bipartite graph matching problem. I think I don't understand the essence of this problem, because to me it seems trivial.</p>&#xA;&#xA;<p>The method of solving the problem says to convert the original bipartite graph into a network, by creating a Source and Sink vertices, directing all edges towards the Sink and setting all edges' capacity to 1. Then I should run Ford-Fulkerson. Fair enough.</p>&#xA;&#xA;<p>My question is, can't I just do this linearly? (Obviously not, but I don't see why). The goal of the problem seems to be to find a maximum matching in a complete bipartite graph - i.e. the maximum number of edges between the two \"sections\" of the graph that do not share any vertices.</p>&#xA;&#xA;<p>To illustrate, see this picture</p>&#xA;&#xA;<p><a href=\"https://i.stack.imgur.com/K5uAS.gif\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/K5uAS.gif\" alt=\"enter image description here\"></a></p>&#xA;&#xA;<ul>&#xA;<li>In the first graph the maximum matching will be 2 - any of the two vertices on the right may only be connected to a single vertex on the left. Since the edges are unweighted, it doesn't really matter which?</li>&#xA;<li>Similarly in the second graph, the matching will again be just 2.</li>&#xA;</ul>&#xA;&#xA;<p>Can you tell me where am I thinking wrong? I don't understand where the complexity of the problem comes from. </p>&#xA;&#xA;<p>And sorry if any of the terms were used incorrectly, I am not studying CS in English. Thanks</p>&#xA;", "<p>Given a graph G=(V,E)  with positive edges weights, Is it possible to produce  different shortest path trees for the Bellman-Ford algorithm and Dijkstra's algorithm?   </p>&#xA;", "<p>I am trying to solve a bounded SSSP problem as follows:</p>&#xA;&#xA;<blockquote>&#xA;  <p>Given a connected weighted graph with non-negative edges (might have&#xA;  cycles), find the shortest path from a vertex s to a vertex t with&#xA;  <strong>at most</strong> k edges.</p>&#xA;</blockquote>&#xA;&#xA;<p>I have done some research on this problem. All proposed solutions point to using Bellman-Ford's algorithm by modifying its outer loop to perform k iterations. This will yield a worst case time complexity of O(VE).</p>&#xA;&#xA;<p>I wish to know if it is possible to solve this in O(k * (V+E)LogV) or better using Dijkstra's algorithm?</p>&#xA;&#xA;<p>I have seen this post that discusses the same problem. <a href=\"https://cs.stackexchange.com/questions/53192/dijkstras-algorithm-to-compute-shortest-paths-using-k-edges\">Dijkstra&#39;s algorithm to compute shortest paths using k edges?</a></p>&#xA;&#xA;<p>However, I don't know how to prove the correctness of the solution that uses product construction.</p>&#xA;&#xA;<p>Could someone please advise me?</p>&#xA;", "<p>I'm a bit confused about stopping at Kth iteration on the Bellman-Ford algorithm to find the shortest path of at most length k from s to t.&#xA;Let me show you a graph and explain you what I understand:</p>&#xA;&#xA;<p><a href=\"https://i.stack.imgur.com/54zOI.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/54zOI.png\" alt=\"graph example\"></a></p>&#xA;&#xA;<p>At first iteration, I will have:</p>&#xA;&#xA;<ul>&#xA;<li>Shortest path to get to A is S->A (cost 1)</li>&#xA;<li>Shortest path to get to B is S->B (cost 4)</li>&#xA;<li>Shortest path to get to T is still unknown</li>&#xA;</ul>&#xA;&#xA;<p>At second iteration I will have:</p>&#xA;&#xA;<ul>&#xA;<li>Shortest path to get to A is S->A (cost 1)</li>&#xA;<li>Shortest path to get to B is A->B (cost 2(A->B) + cost 1(S->A) = 3) <strong>updated!</strong></li>&#xA;<li>Shortest path to get to T is B->T</li>&#xA;</ul>&#xA;&#xA;<p>But now going to B takes 2 edges instead of 1, so going to T is 3 edges away now: S->A->B->T, and this has happened in 2 iterations.</p>&#xA;&#xA;<p>What am I understanding wrong?</p>&#xA;", "<p>I am working on a project where I need to be able to compute the <a href=\"https://en.wikipedia.org/wiki/Maximum_flow_problem\" rel=\"nofollow\">maximum flow</a> between two nodes in a graph after one of the edge weights has been incremented or decremented by 1. The graph is directed and edge weights are all integers. I can find the maximum flow the first time, by <a href=\"https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm\" rel=\"nofollow\">Ford-Fulkerson's algorithm</a> or some variant, but at each step thereafter it would be great if I could use a different (faster) algorithm to find the max flow. At each step, only one of the edge weights is changed, and it is only changed by a value of +1 or -1. What sort of algorithm could do this incremental update for me? It needs to be faster than recomputing the max flow from scratch. It could also be two separate algorithms (but similar I would hope): one for the incrementing case and one for the decrementing case. Thanks in advance for the help!</p>&#xA;", "<p>Suppose I have a graph on which I've run the Bellman-Ford algorithm. Now I change the weight of subset of edges. Is there an efficient way to re-run the algorithm without having to completely start over? That is, can I update the shortest path in an \"online\" manner, if I'm only changing a subset of weight edges each time?</p>&#xA;", "<p>According to my understanding, the Bellman\u2013Ford algorithm can handle cyclic graphs with negative weights. but it cannot have negative cycles. But can it handle zero weight cycles? </p>&#xA;", "<p>This is the 24.1-5 question in CLRS. I'm having a hard time understanding the questions and also how to solve it. \u03b4(u,v) is defined as the shortest path weight from u to v if there exist a path from u to v.</p>&#xA;&#xA;<p>Let G=(V,E) be a weighted, directed graph with weight function w:E\u2192R. Give an O(VE)-time algorithm to find, for each vertex v\u2208V, the value \u03b4\u2217(v)=Min u\u2208V{\u03b4(u,v)}.</p>&#xA;&#xA;<p>What I'm confusing about this question is what is \u03b4\u2217(v) suppose to be. I also found the answer online but still don't really understand why it is like that. Since this is an exercise in the Bellman-Ford algorithm of CLRS. the answer said to change the RELAX operation of the algorithm. The RELAX operation in Bellman-Ford is what help achieve the shortest path weight after you run this V time for each edge in E.</p>&#xA;&#xA;<p>the ORIGINAL-RELAX operation supposes to be like this: </p>&#xA;&#xA;<pre><code>RELAX(u, v, w)&#xA;if v.d &gt; u.d + w(u,v)&#xA;   v.d = u.d + w(u,v)&#xA;   v.pi = u.pi&#xA;</code></pre>&#xA;&#xA;<p>With v.d and u.d being the upper bound for the shortest path from source to u and v. v.pi is supposed to be its predecessor for the current upper bound.</p>&#xA;&#xA;<p>The answer said to change the RELAX operation to this.</p>&#xA;&#xA;<pre><code>MOD-RELAX(u, v, w)&#xA;if v.d &gt; min(w(u, v), w(u, v) + u.d)&#xA;   v.d = min(w(u, v), w(u, v) + u.d)&#xA;   v.pi = u.pi&#xA;</code></pre>&#xA;&#xA;<p>I need some explaination to what the problem is asking for and why this answered it.</p>&#xA;", "<p>Given a weighted, directed graph (V, E) may contains some negative cycles and a source node <code>s</code>, I would like to know for all node <code>u</code>, if there is a path from <code>s</code> to <code>u</code> but there is no shortest path from <code>s</code> to <code>u</code> (the distance from <code>s</code> to <code>u</code> is minus infinite). To do this I implemented a version of the Bellman-Ford algorithm:</p>&#xA;&#xA;<pre><code>Do V iterations of Bellman-Ford, save all nodes relaxed on Vth iteration to a queue `Q`&#xA;Do BFS with `Q` and find all nodes reachable from `Q`&#xA;All those nodes and only those can have infinite distance from `s`&#xA;</code></pre>&#xA;&#xA;<p>Here is BFS:</p>&#xA;&#xA;<pre><code>visited(Q.first) = true&#xA;while Q not empty:&#xA;    u &lt;- Q.deQueue()&#xA;    shortest[u] = 0 // there is no shortest path from `s` to `u`&#xA;    for all (u, v) in E:&#xA;        if not visited(v):&#xA;            visited(v) = true&#xA;            Q.push(v)&#xA;</code></pre>&#xA;&#xA;<p>This algorithm is the best I can come up with and sadly it fails some test cases. I would be greatly appreciated if you guys can help, thanks.</p>&#xA;", "<p>I am exploring some ideas around dating site matching, and I can do with some ideas as to which is the better solution</p>&#xA;&#xA;<p>Senario: We have a boy and girl, the boy has completed his profile/bio thoroughly while the girl hasn't or maybe she just doesn't like a lot of things, so this is what the data looks like</p>&#xA;&#xA;<pre><code>Boy likes:                  Girl likes:&#xA;---------                   -----------&#xA;Painting                    Painting&#xA;Movies                      Movies&#xA;Long walks                  Long walks  &#xA;Harry Potter                Harry Potter&#xA;Dogs                        Dogs&#xA;Pizza                       Pizza&#xA;Computer Science            Computer Science&#xA;Mercedes                    Ford&#xA;Traveling                   Daisies&#xA;Diving                      Psycology&#xA;...&#xA;&#xA;Total things&#xA;---------------------------------------&#xA;100                         10&#xA;</code></pre>&#xA;&#xA;<p>They share 7 things in common. To the girl the boy is a 70% match which is great&#xA;But to the boy the girl is only a 7% match</p>&#xA;&#xA;<p>Maybe the girl would have more in common if she had more in her list of likes so maybe giving their match a 7/100 is a match missed and maybe that's all she likes and 7/100 is the best they'll ever match but even then, it still might be a good match because maybe the boy over filled his list of things he likes while the girl chose carefully what she really likes.</p>&#xA;&#xA;<p>I am looking for ideas for an algorithm that would give the best match score to order them in lists with other people/matches who might have small percentage in matches because their lists of things they like are 1000s of entries long for example</p>&#xA;&#xA;<p><strong>Edit:</strong> I will not be matching strings, each of strings in the table above will have a unique ID in an RDBMS database. A table will be used to link users and topics</p>&#xA;", "<p><strong>Problem:</strong></p>&#xA;&#xA;<blockquote>&#xA;  <p>Let $G = (V,E)$ be an infinite digraph, such that $V = \\mathbb{N}$, and $E \\subset \\mathbb{N}\\times \\mathbb{N}$ is decidable set. Does it imply&#xA;  that $\\delta (i,j)$ is a total function?  </p>&#xA;  &#xA;  <p>*(where $\\delta (i,j)$ is the shortest path function between vertex&#xA;  $i$ and $j$).</p>&#xA;</blockquote>&#xA;&#xA;<p>I'm having a hard time trying to understand the problem, so any help would be appreciate.</p>&#xA;&#xA;<hr>&#xA;&#xA;<p>Well, this is what I know (hopefully I'm not misunderstanding anything here):</p>&#xA;&#xA;<p>A language (or set) $L$ is decidable if $\\exists$ and algorithm $A$, such that if $v \\in L$, then $A(v) = \\text{Accept}$ and halts and if $v\\not\\in L$, then $A(v) = \\text{Reject}$ and halts.</p>&#xA;&#xA;<p>A function $f$ is total if $\\exists$ and algorithm $B$ that computes it $\\forall v\\in \\mathrm{Dom}(f)$ and always halts.</p>&#xA;&#xA;<hr>&#xA;&#xA;<p><strong>My attempt:</strong></p>&#xA;&#xA;<p>Suppose $\\delta (i,j)$ is a total function and let algorithm $B$ be the Bellman-Ford algorithm ($BFA$).</p>&#xA;&#xA;<p>The relaxation step in $BFA$ is given by</p>&#xA;&#xA;<pre><code>// Step 2: relax edges repeatedly&#xA;   for i from 1 to size(vertices)-1:&#xA;       for each edge (u, v) with weight w in edges:&#xA;           if distance[u] + w &lt; distance[v]:&#xA;               distance[v] := distance[u] + w&#xA;               predecessor[v] := u&#xA;</code></pre>&#xA;&#xA;<p>Because $|V| = \\infty$ we have that the algorithm never halts, since <code>size(vertices) - 1</code> $= |V| -1 = \\infty$. This implies that $BFA$ doesn't compute $\\delta (i,j) \\implies \\delta (i,j)$ is not a total function (So, to my understanding it would be only a partial function, since $\\exists$ some vertices $u,\\ v$ for which the function $\\delta (u,v)$ is undefined).</p>&#xA;&#xA;<p>Although to me at first glance it makes kind of sense, I guess I'm wrong, mainly because I didn't consider the fact that $E$ is a decidable set.</p>&#xA;", "<p>I'm taking a fairly challenging Algorithm course, in which we are learning about algorithms such as Dijkstra, Bellman-Ford etc. as well as the algorithm design patterns such as recursions, DP and various graph construction techniques such as layering. Now I really have some trouble to design correct and efficient algorithm using stuff we learned in the class. To be specific, I'm having trouble with following:</p>&#xA;&#xA;<ul>&#xA;<li>Design an algorithm that's fast enough, i.e., I came up with a $O(n^2)$ algorithm but in fact there is a $O(n log n)$ algorithm. </li>&#xA;<li>To find the edge cases for the algorithm I designed. It happened a lot of times to me during exam that I designed some seemingly correct algorithm but will actual fail in some edge cases. I always have some hard time to find those edge cases and therefore falsely believe the algorithm is correct.</li>&#xA;</ul>&#xA;&#xA;<p>I would greatly appreciate any suggestions that can help me deal with my struggle. Also, just for reference, here are the links to the course I'm taking (<a href=\"https://courses.engr.illinois.edu/cs374/lectures.html\" rel=\"nofollow noreferrer\">schedule</a>, and the <a href=\"https://courses.engr.illinois.edu/cs374/work.html\" rel=\"nofollow noreferrer\">homeworks</a>)</p>&#xA;", "<blockquote>&#xA;<p>The eccentricity of a vertex v is the length of the shortest path from that vertex to the furthest vertex from v in an undirected graph. The diameter of an undirected graph is the maximum eccentricity of any vertex. The radius of an undirected graph is the smallest eccentricity of any vertex. A center is a vertex whose eccentricity is the radius. Assuming a connected, unweighted, undirected graph G, give an algorithm to compute the radius of G.</p>&#xA;</blockquote>&#xA;<p>I am using the definitions given above to compute a radius for a connected, unweighted, undirected graph.  So far, my algorithm consists of this:</p>&#xA;<ol>&#xA;<li><p>For each vertex <span class=\"math-container\">$v$</span> in graph<span class=\"math-container\">$ $</span>G, use Bellman-Ford to find the furthest vertex from <span class=\"math-container\">$v$</span> (longest of the shortests paths found).</p>&#xA;</li>&#xA;<li><p>record the path <span class=\"math-container\">$s_0,s_1,s_2,\\ldots,s_n$</span> for vertexes <span class=\"math-container\">$1,2,3,\\ldots,n$</span>.</p>&#xA;<p>Note: the order of the chosen vertexes is arbitrary, as long as all vertexes are analyzed once and only once.</p>&#xA;</li>&#xA;<li><p>Compare all paths <span class=\"math-container\">$s_0,s_1,s_2,\\ldots,s_n$</span> and return the shortest path in the set of recorded paths.</p>&#xA;</li>&#xA;</ol>&#xA;<p>My question is if this algorithm works, or if it doesn't, how I can modify it to fix it or make it better.  I know that Bellman-Ford computes the shortest path to every vertex in the graph so doing this for every vertex in the graph would be pretty exhaustive, perhaps even unnecessary.</p>&#xA;", "<p>There are plenty material about bidirectional search with non-negative edge weights. One example is <a href=\"http://www.slac.stanford.edu/pubs/slacreports/reports04/slac-r-104.pdf\" rel=\"nofollow noreferrer\">this paper</a>. I am looking for any improvements using a bidirectional approach for acyclic digraphs with possibly negative weight edges.</p>&#xA;&#xA;<p>The main approach for mono-directional search on possibly negative edge weights is Bellman-Ford. However, i don't think there's any valid early termination criteria that makes bidirectional Bellman-Ford better than the mono-directional.</p>&#xA;&#xA;<p>Can someone provide ideas or references for a bidirectional search on an acyclic digraphs with possibly negative edge weights?</p>&#xA;&#xA;<p>Thanks in advance.</p>&#xA;", "<p>This is my first question here and I hope you can help mt clarifying a doubt.<br>&#xA;Basically, I'm studying shortest path algorithms, for instance Dijkstra, Bellman-Ford-Moore, and I came up with a doubt.<br>&#xA;From what I understood, given a node of a graph, these algorithms calculate all the shortest paths to the other nodes. So, if I block the execution when a specific condition is met, I can get just the shortest path between two nodes.<br>&#xA;I don't have problems with Dijkstra but I can't prove this assumption with Bellman-Ford-Moore algorithm. Consider this example:<br>&#xA;<code>G = (V,E)</code> <em>directed</em> graph where <code>V = {1,2,3,4,5,6}</code>, <code>E = {(1,3),(1,2),(3,2),(3,4),(2,5),(5,4),(4,6),(5,6)}</code> and each arch has the following <code>costs</code>, respectively: <code>2,1,3,3,1,2,2,5</code>.  </p>&#xA;&#xA;<p>The shortest path between <code>node 1</code> and <code>node 4</code> is: <code>1 -&gt; 2 -&gt; 5 -&gt; 4</code> whose cost is 4.<br>&#xA;If I try to execute BFM on this graph, assuming nodes are added in the queue with this order: <code>1,3,2,4,5</code>; the result is not what I'm expecting because the algorithm terminates returning the path <code>1 -&gt; 3 -&gt; 4</code>, whose cost is 5.  </p>&#xA;&#xA;<p>This is the pseudocode I'm using:  </p>&#xA;&#xA;<pre><code>bfm(GRAPH G, NODE r, NODE s, integer[] T)&#xA;   integer[] d &lt;- new integer[1...G.n]&#xA;   boolean[] b &lt;- new integer[1...G.n]&#xA;&#xA;   foreach u in G.V() - {r} do&#xA;      T[u] &lt;- nil&#xA;      d[u] &lt;- inf&#xA;      b[u] &lt;- false&#xA;&#xA;   T[r] &lt;- nil&#xA;   d[r] &lt;- 0&#xA;   b[r] &lt;- true&#xA;&#xA;   QUEUE S &lt;- new Queue()&#xA;   Q.enqueue(r)&#xA;&#xA;   while not S.isEmpty() do&#xA;      NODE u &lt;- S.dequeue()&#xA;      b[u] &lt;- false&#xA;      if u = s then return&#xA;&#xA;      foreach v in G.adj(u) do&#xA;         if d[u] + w(u,v) &lt; d[v] then&#xA;            if not b[v] then&#xA;               S.enqueue(v)&#xA;               b[v] &lt;- true&#xA;&#xA;            T[v] &lt;- u&#xA;            d[v] &lt;- d[u] + w(u,v)&#xA;</code></pre>&#xA;&#xA;<p><code>d</code> is a vector to track distances, <code>b</code> is a vector to track which node is currently in the queue, <code>T</code> is a vector of fathers, <code>G.adj(u)</code> returns all nodes adjacent to node <code>u</code> and <code>w(u,v)</code> is the cost function.  </p>&#xA;&#xA;<p>Since Dijkstra and BFM algorithms are quite similar, I thought my assumption would be valid for both of them but it seems that I'm wrong. Can you please help me understanding if and how I can use BFM to get the shortest path between two specific nodes?  </p>&#xA;&#xA;<p>Thank you so much!</p>&#xA;", "<p>The book <a href=\"https://books.google.com/books?id=idUdqdDXqnAC&amp;pg=PA684&amp;lpg=PA684&amp;dq=edge+weights+negative+efficient+available+bellman+ford+sedgewick&amp;source=bl&amp;ots=ZZC4X7eemO&amp;sig=8coCNFAZMRB6f2su6vyp_6ia2Ms&amp;hl=en&amp;sa=X&amp;ved=0ahUKEwiR77Ox8LDUAhVB6WMKHUQFBJEQ6AEIQjAF#v=onepage&amp;q&amp;f=false\" rel=\"nofollow noreferrer\">&quot;Algorithms&quot;</a> by Robert Sedgewick and Kevin Wayne hinted that (<em>see the quote below</em>) there are efficient algorithms for finding shortest paths in undirected graphs with possibly negative edge weights (<em><strong>not</strong></em> by treating an undirected edge as two directed one which means that a single negative edge implies a negative cycle). However, no references are given in the book. Are you aware of any such algorithms?</p>&#xA;<blockquote>&#xA;<p>Q. How can we find shortest paths in undirected (edge-weighted) graphs?</p>&#xA;<p>A. For positive edge weights, Dijkstra's algorithm does the job. We just build an EdgeWeightedDigraph corresponding to the given EdgeWeightedGraph (by adding two directed edges corresponding to each undirected edge, one in each direction) and then run Dijkstra's algorithm. <em><strong>If edge weights can be negative</strong></em> (<em><strong>emphasis added</strong></em>), efficient algorithms are available, but they are more complicated than the Bellman-Ford algorithm.</p>&#xA;</blockquote>&#xA;", "<p>After reviewing the Bellman-Ford algorithm I can see that it runs with time complexity of $O(n^2)$ or, more exactly, $O(VE)$. It is necessary to loop (V-1) times the number of edges which is in fact 2 nested loops. This is true even if it includes the detection of negative cycles because this task only needs a last loop. However, I have seen that the algorithm time complexity is $O(n^3)$ in some sites. Specifically, the site where I saw it explains 2 steps:</p>&#xA;&#xA;<ol>&#xA;<li>A graph is built using 2 nested loops.</li>&#xA;<li>Bellman-Ford is applied to detect negative cycles.</li>&#xA;</ol>&#xA;&#xA;<p>Such a site says that $step$ $1$ is $O(n^2)$ (which is logical) and $step$ $2$ is $O(n^3)$</p>&#xA;&#xA;<p>Is this possible? I will very much appreciate your feedback because I cannot find a logical explanation.</p>&#xA;&#xA;<p>Respectfully,<br />&#xA;Jorge Maldonado</p>&#xA;", "<p>I am trying to solve the shortest path problem between n cities. Any single pair shortest path algorithm such as Dijkstra's and Bellman-Ford would work here, but if we add a simple additional constraint \"the total time should not exceed T time units\", then the problem becomes much harder.</p>&#xA;&#xA;<p>More formally:</p>&#xA;&#xA;<p>The input consists of a set of n cities and m roads between pairs of cities. There can be  multiple roads between a pair of cities $(i, j)$. For each road, you are given its departure city $x_i$, its destination city $y_i$, its duration $d$, and its cost $c$. The objective is to find the cheapest path between a pair of cities $(a, b)$ such that the cost is minimized while keeping the duration less than the maximum duration $T$.</p>&#xA;&#xA;<p>I tried thinking on the lines of Dijkstra's and modifying the graph so that it is in some way possible to run a shortest path algorithm on it, but there seems to be no trivial way of doing this. Simple solutions like (follow a greedy strategy until you exceed the time limit, and then move on to the next element in the priority queue) don't seem to work because the use of a priority queue in the Dijkstra's algorithm and DEQUEUING the minimum element from the priority queue behave like destructive operations. There is a need to backtrack (of sorts) but the shortest path algorithms visit each node in the graph only once.</p>&#xA;&#xA;<p>I've tried thinking about other simpler approaches using the Bellman-Ford algorithm, but the time complexity of the algorithm I  turned out writing depended on $T$ (which is not very desirable).</p>&#xA;&#xA;<p>I spent almost 2 days on this and every solution I try either seems to not work, or runs in exponential time. Is this problem NP hard or are there polynomial time solutions possible?</p>&#xA;&#xA;<p>P.S. I am not looking for a practical implementation of this problem, just an algorithm that can solve this problem in polynomial time. Although any thoughts about how to efficiently implement this would be more than welcome :)</p>&#xA;", "<p>I have a graph like this one:<a href=\"https://i.stack.imgur.com/kp3KB.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/kp3KB.png\" alt=\"Graph\"></a></p>&#xA;&#xA;<p>Each step from one node to another is a multiplication.</p>&#xA;&#xA;<p>So for instance given the entry node TE and an entry value of 1.</p>&#xA;&#xA;<p>TE = 1</p>&#xA;&#xA;<p>TB = 1/10010</p>&#xA;&#xA;<p>GB = 999/(10010*1000)</p>&#xA;&#xA;<p>GE = (19990*999)/(10010*1000)</p>&#xA;&#xA;<p>and so on.</p>&#xA;&#xA;<p>I want to find the best path from TE to TE to return the highest value.</p>&#xA;&#xA;<p>In this case is</p>&#xA;&#xA;<p>TE TB GB GE TE = 1,993010988</p>&#xA;&#xA;<p>I tried to apply Dijkstra's SPF but it doesn't work because each step can &#xA;increment or decrement so it's not monotone  </p>&#xA;&#xA;<p>neither Bellman\u2013Ford algorithm is applicable here because the graph contains negative cycle. (e.g. TE TB TE). </p>&#xA;&#xA;<p>Anyone has some clue if this problem has a solution ?</p>&#xA;", "<blockquote>&#xA;  <p>I need to find the minimal path cost from left edge of a $n\\times n$ grid to the right edge where each node has some non-negative weight $cost(i,j)$. $i$ represents horizontal coordinates while $j$ represents vertical coordinates. Only the following movements are allowed in the grid:&#xA;  $$&#xA;(i,j)\\to(i+1, j-1) \\quad\\text{aka diagonal down}\\\\&#xA;(i,j)\\to(i+1, j) \\quad\\text{aka right}\\\\&#xA;(i,j)\\to(i+1, j+1) \\quad\\text{aka diagonal up}\\&#xA;$$&#xA;  The algorithm must run in $\\Theta(n^2)$ time and use dynamic programming.</p>&#xA;</blockquote>&#xA;&#xA;<p>I thought:</p>&#xA;&#xA;<p>1) first to select the minimal cost node in the left-most column, that is find $min(cost(i, 1))$. Let the node be $s$ (start node).</p>&#xA;&#xA;<p>2) Now we can use Bellman-Ford algorithm as described <a href=\"https://www.cs.cmu.edu/~avrim/451f12/lectures/lect1002.pdf\" rel=\"nofollow noreferrer\">here</a> (page 53) in order to find the minimal cost path from $s$ to any other node. The recurrence for Bellman-Ford would be:&#xA;$$&#xA;opt(i,j) = cost(i,j) + min(opt(i+1,j-1),\\\\ opt(i+1, j),\\\\ opt(i+1,j+1))&#xA;$$</p>&#xA;&#xA;<p>3) We'd get a $n\\times n$ matrix in the end where the right-most column would represent the right-most edge of the grid. Therefore the minimal cost path from left edge to the right edge would be the minimal cost in the right column. </p>&#xA;&#xA;<hr>&#xA;&#xA;<p>Is my logic on the right track? I'm really not sure regarding the steps 1) and 3). Also because Bellman-Ford calculates edges costs do I need to perform any reduction in this algorithm because costs are not stored on edges but rather on nodes?</p>&#xA;", "<p>Vertices in my graph are composed of {name, category} where category is one of {red, grn, blu, ylw}. Edges in my graph are weighted and directed. In the visualization, the thick end of the edge represents the destination.</p>&#xA;&#xA;<p><a href=\"https://i.stack.imgur.com/TLU1P.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/TLU1P.png\" alt=\"Graph Visualization\"></a></p>&#xA;&#xA;<p>My graph has negative cycles, for example [A-red, B-red, C-blu, X-grn, D-blu, A-red] has a cost of -1, comprised of edge costs [1, 1, -1, -3, 1].</p>&#xA;&#xA;<p>I want to find the shortest path between arbitrary {source, destination} vertices subject to the following conditions:</p>&#xA;&#xA;<ol>&#xA;<li>Each vertex may only be visited once.</li>&#xA;<li>The count of vertexes visited along the path must be &lt;= m</li>&#xA;<li>The count of categories visited along the path must be &lt;= n</li>&#xA;</ol>&#xA;&#xA;<p>So, for example, assuming a function <code>shortest_path(source, dest, m, n)</code> then: </p>&#xA;&#xA;<p><code>shortest_path(('A','red'), ('D','ylw'), 100, 100)</code> would return [A-red, B-red, C-blu, X-grn, D-ylw] which has a cost of -2. This path visits 4 vertex categories [red, blu, grn, ylw].</p>&#xA;&#xA;<p><code>shortest_path(('A','red'), ('D','ylw'), 100, 3)</code> would return [A-red, B-red, C-blu, D-ylw] for a cost of 3. This path visits 3 vertex categories [red, blu, ylw].</p>&#xA;&#xA;<p>Any suggestions here? I believe Dijkstra's algorithm and Bellman-Ford are out here as my graph contains negative cycles. So I think i need a brute force search of edges, integrating the stopping conditions mentioned above.</p>&#xA;&#xA;<p>Python code for initializing my graph is here:</p>&#xA;&#xA;<pre><code>import networkx as nx&#xA;&#xA;class Vertex(object):&#xA;    def __init__(self, name, category):&#xA;        self.name = name&#xA;        self.category = category&#xA;    def __hash__(self):&#xA;        return hash((self.name, self.category))&#xA;    def __eq__(self, other):&#xA;        if isinstance(other, Vertex):&#xA;            return other.name == self.name and other.category == self.category&#xA;    def __str__(self):&#xA;        return '{}-{}'.format(self.name, self.category)&#xA;    def __repr__(self):&#xA;        return str(self)&#xA;&#xA;d = {&#xA;    Vertex('A','red') : {Vertex('B','red') : {'weight':1}},&#xA;    Vertex('B','red') : {Vertex('C','blu') : {'weight':1}},&#xA;    Vertex('C','blu') : {Vertex('D','ylw') : {'weight':1}, Vertex('X','grn') : {'weight':-1}},&#xA;    Vertex('D','ylw') : {Vertex('A','red') : {'weight':1}},&#xA;    Vertex('X','grn') : {Vertex('D','ylw') : {'weight':-3}},&#xA;}&#xA;G = nx.DiGraph(d)&#xA;&#xA;pos = nx.circular_layout(G)&#xA;nx.draw_networkx(G,pos, arrows=True, with_labels=True)&#xA;labels = nx.get_edge_attributes(G,'weight')&#xA;nx.draw_networkx_edge_labels(G,pos, edge_labels=labels);&#xA;</code></pre>&#xA;&#xA;<p><strong>Update</strong>&#xA;Here is my current traversal algorithm, its essentially a DFS but I record both the parent of each vertex I examine, and the cost of traversing from the parent to the vertex. This allows me to reconstruct a path and compute a total cost for the path. However, I'm not sure its a great solution. My aim is to get the algorithm working well then port to cython for performance (my real graph is huge).</p>&#xA;&#xA;<pre><code>#DFS&#xA;def calcd(parents, distances):&#xA;    d = 0&#xA;    for v in parents[1:]:&#xA;        d+=distances[v]&#xA;    return d&#xA;&#xA;def backtrace(parent, start, end):&#xA;    path = [end]&#xA;    while path[-1] != start:&#xA;        path.append(parent[path[-1]])&#xA;    path.reverse()&#xA;    return path&#xA;&#xA;def dfs(graph, source, target):&#xA;    visited = set()&#xA;    stack = list()&#xA;    parent = {}&#xA;    distance = {}&#xA;&#xA;    stack.append(source)&#xA;&#xA;    while stack:&#xA;        u = stack.pop()&#xA;        uob = graph[u] #edges outbound from u&#xA;&#xA;        for v, eparams in uob.items():&#xA;            parent[v] = u&#xA;            distance[v] = eparams['weight']&#xA;&#xA;            if v == target:&#xA;                path = backtrace(parent, source, target)&#xA;                print('Reached Target via {}'.format(path))&#xA;                print('calcd', calcd(path, distance))&#xA;&#xA;            if v not in visited:&#xA;                visited.add(v)&#xA;                stack.append(v)&#xA;&#xA;source, target = Vertex('A','red'), Vertex('D','ylw')&#xA;dfs(G, source, target)&#xA;</code></pre>&#xA;&#xA;<p>This prints:</p>&#xA;&#xA;<pre><code>Reached Target via [A-red, B-red, C-blu, D-ylw] calcd 3 &#xA;Reached Target via [A-red, B-red, C-blu, X-grn, D-ylw] calcd -2&#xA;</code></pre>&#xA;", "<p>If you apply standard Bellman-Ford algorithm to a graph containing negative loop it can only report its existence. Are there approaches to modify it to find shortest path containing any vertex not more than once so effectively avoiding loops? I would appreciate if an answer will contain a link to a paper.</p>&#xA;", "<p>I am trying to find the path for the most negative cycle in a graph G which starts and ends at a specified source node S.</p>&#xA;&#xA;<p>I have studied an application/ extension of the Bellman-Ford algorithm (henceforth referred to as the \"Huang algorithm\") found <a href=\"http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.86.1981&amp;rep=rep1&amp;type=pdf\" rel=\"nofollow noreferrer\">here</a> which describes how to find a negative cycle reachable from a specified node. However, this does not ensure that the \"full cycle\" going from S -> cycle -> S is negative.</p>&#xA;&#xA;<p>Here is my current research into this topic:</p>&#xA;&#xA;<p>On the n<sup>th</sup> iteration of the Bellman Ford algorithm, if an edge can be relaxed, then the graph contains a negative cycle. Using the Huang algorithm I can retrace the path of the negative cycle through the predecessor dictionary until a vertex repeats. When a vertex repeats, I cease iterating over the predecessor and now have my path for the negative cycle. However, the source vertex is often not in this path. I believe it is also sometimes not the most negatively-weighted path. </p>&#xA;&#xA;<p>I would like to find the most negative cycle of which S is a part. (This can include a cycle with a subcycle detected by the Huang algorithm)</p>&#xA;", "<p>Given a directed acyclic (and unweighted) graph and two distinct vertices S and T, is there an algorithm that will tell me if there is <em>any</em> path (not necessarily the shortest one) between the two? If it helps, I don't need the list of vertices on this path, just the fact that path exists.</p>&#xA;&#xA;<p>I sure know of all the graph shortest-path algorithms (Dijsktra/Bellman-Ford/topological sorting/etc.), but I don't actually need the shortest one. Is there a speedy method of finding any arbitrary path in a DAG between two nodes? Pretty sure there is aplenty of specialized algorithms for that, just not sure where to search for.</p>&#xA;", "<p>I was studying the chapter 24 of the <a href=\"https://dl.acm.org/citation.cfm?id=1614191\" rel=\"nofollow noreferrer\">CLRS</a> and got to the following question:</p>&#xA;&#xA;<blockquote>&#xA;  <p><strong>24.1-5</strong> $\\star$ Let $G=(V,E)$ be a weighted, directed graph with weight function $w : E \\rightarrow \\mathbb{R}$. Give an $O(VE)$-time&#xA;  algorithm to find, for each vertex $v \\in V$, the value $\\delta^{*}(v) = \\min_{u \\in V}\\{\\delta(u,v)\\}$.</p>&#xA;</blockquote>&#xA;&#xA;<p>From what I understood, he wants an algorithm to find the shortest path beginning in any $u \\in V-\\{s\\}$ to every vertex $v \\in V$. So, this algorithm would return one shortest path for each vertex in $V$ in $O(|V||E|)$. I couldn't come with any other answer besides using an All-Pairs Shortest Paths algorithm and choosing the paths with less value for each vertex. But, as this chapter is about the Bellman-Ford, this is probably some modification from the original algorithm.</p>&#xA;&#xA;<p>If someone could point me in the right direction, I would really appreciate.</p>&#xA;", "<p>I have an unweighted and undirected graph, and I want to divide this graph into two connected components by removing some vertices. The main objective is to minimize the number of vertices which must be deleted in order to partition the graph into two sub graphs.</p>&#xA;&#xA;<p>How can I accomplish this ? </p>&#xA;&#xA;<p>The first thing coming to my mind is <code>Ford Fulkerson</code>algorithm, but I think it is not appropriate for this problem.</p>&#xA;", "<p>I was asked the following problem in an interview:</p>&#xA;&#xA;<p>Let M be a N X N matrix, such that:</p>&#xA;&#xA;<pre><code>M[i][j] &gt;= 0; 1 &lt;= i,j &lt;= N and i != j&#xA;&#xA;M[i][j] = 0; if i = j&#xA;&#xA;M[i][j] = M[j][i]; 1 &lt;= i,j &lt;= N&#xA;</code></pre>&#xA;&#xA;<p>We are allowed to increase any of the entry in <code>M[i][j]</code> by any positive number, that we can increase the value of any cell in <code>M[i][j]</code> as much as we want.</p>&#xA;&#xA;<p>Let <code>M'</code> be the matrix obtained by changing some values in <code>M</code> and <code>x</code> be the sum of all the changes made in M.</p>&#xA;&#xA;<p>The task is to obtain M' such that it represents a graph with N vertex and satisfies following two conditions:-</p>&#xA;&#xA;<ol>&#xA;<li><code>M'[i][j]</code> = max flow between vertex <code>i</code> and <code>j</code>, since the graph is undirected, trivially <code>M'[i][j] = M'[j][i]</code>.</li>&#xA;<li>x is minimized, that is sum of all the changes made in M to get M' is minimum.</li>&#xA;</ol>&#xA;&#xA;<p>consider for example, </p>&#xA;&#xA;<pre><code>M = &#xA;0 7 11 6&#xA;7 0 9 8&#xA;11 9 0 4&#xA;6 8 4 0&#xA;&#xA;M'=&#xA;0 9 11 8&#xA;9 0 9 8&#xA;11 9 0 8&#xA;8 8 8 0&#xA;&#xA;x = 16.&#xA;</code></pre>&#xA;&#xA;<p>Here is how I approached the problem.</p>&#xA;&#xA;<ol>&#xA;<li>Assume that in <code>M</code>, <code>M[i][j]</code> refers to the weight between vertex <code>i</code> and <code>j</code>.</li>&#xA;<li>Try creating a <code>Maximum Spanning Tree</code> from the values in M[i][j](I used <code>Kruskal's Algorithm</code>).</li>&#xA;<li>Now, while adding an edge between some pair i and j in the Maximum ST, one of the two conditions may arise- either no path exists between i and j, in this case simply add this edge between them, since we have been adding edges in a non-increasing order(as we are creating a Maximum Spanning Tree) this will be a 'bottleneck-edge' in the path between <code>i</code> and <code>j</code>, and so according to the <code>Ford Fulkerson's algorithm</code> this is also the max flow between i and j, so no changes required to be made(<code>i</code>.e. nothing to increase here as the max-flow is equal to the initial value <code>M[i][j]</code>). The other case is when there already exists a path between i and j, and since we are adding edges in non-increasing fashion, the current flow between i and j will be greater than the value M[i][j], thus <code>M[i][j]</code> need to be incremented. This change will be equal to <code>2*(current_flow_between_i_and_j - M[i][j])</code>(as both M[i][j] and M[j][i] need to be changed and by equal amount).</li>&#xA;</ol>&#xA;&#xA;<p>And my approach was actually giving correct answer to the example test cases given by the interviewer, but to my surprise the interviewer told me that my approach was wrong and won't always work. I even tried my approach on test cases made by myself, and it seems to work correctly(or atleast this what I think). Where am I wrong in my approach and what can be a correct solution? </p>&#xA;", "<p>From my understanding, a problem amenable to a dynamic programming solution has these two properties:</p>&#xA;&#xA;<ol>&#xA;<li><strong>Overlapping Subproblems</strong> &mdash; The same subcase (a subsection of the overall problem) keeps reappearing. Thus, memoization can be used to boost performance.</li>&#xA;<li><strong>Optimal Substructure</strong> &mdash; The problem can be broken down into smaller components, which can then be solved independently and the results combined to produce the answer to the overall problem. This allows for subproblems and possibly overlapping subproblems.</li>&#xA;</ol>&#xA;&#xA;<p>I've read that Bellman-Ford and Floyd-Warshall are dynamic programming algorithms, but how do I think of them in terms of the two properties given above?</p>&#xA;", "<p>In a Distance Vector routing protocol each node implements a Bellman-Ford inspired algorithm that shares it's routing table (Distance Vector) with each of it's incoming links (upstream neighbors).  How would a source node identify a destination node it could reach at an infinitely low cost by traversing a negative cycle over and over again?  </p>&#xA;", "<p>Let <span class=\"math-container\">$G=(V,E)$</span> be a directed graph, <span class=\"math-container\">$\\omega : E \\rightarrow R$</span> a weight function, and <span class=\"math-container\">$s,t \\in V$</span> a pair of different nodes. It's given that <span class=\"math-container\">$G$</span> doesn't have a negative cycle. Moreover, 10 of its edges are colored in red (let's say that the rest are colored in blue).</p>&#xA;&#xA;<p>I want to find an efficient algorithm that find the shortest path between <span class=\"math-container\">$s$</span> and <span class=\"math-container\">$t$</span> that goes through at least 5 different red edges. </p>&#xA;&#xA;<p>Notice that going more than once through the same red edge is still considered as going through 1 red edge in the path.</p>&#xA;&#xA;<p>One idea that I had was creating a graph <span class=\"math-container\">$G'$</span> that will have a copy of every node for every possible set of red edges in <span class=\"math-container\">$G$</span>. That means that if we go through some red edge <span class=\"math-container\">$e$</span>, then the path will \"move\" to a variation of <span class=\"math-container\">$G$</span> where <span class=\"math-container\">$e$</span> is colored in blue and all the rest is the same.</p>&#xA;&#xA;<p>However in this solution I will have to copy each node and each edge around 400 times. This will result in the same complexity asymptotically, but with such a big constant it seems really not efficient.</p>&#xA;&#xA;<p>Another idea, was to somehow build the new graphs \"on the run\" of Bellman-Ford algorithm, but I don't really know how to do it.</p>&#xA;&#xA;<p>I'll appreciate some help.</p>&#xA;", "<p>Consider the following inefficient algorithm that decides if there is a path between two vertices s and t of a directed graph G. Show that the algorithm is correct. In addition, analyze its complexity and compare it with the other path between two vertices algorithms (Dijsktra, Bellman-Ford Algorithm, etc.) and explain why this algorithm is inefficient.</p>&#xA;&#xA;<pre><code>ALGORITHM Reachable(G, s, t)&#xA;     RETURN A(G,s,t,|V(G)|)&#xA;END Reachable&#xA;&#xA;FUNCTION A(G,s,t,d)&#xA;     IF d=1 THEN&#xA;        IF s == t OR there is a directed edge (s,t) in G THEN&#xA;              RETURN TRUE&#xA;        ELSE&#xA;              RETURN FALSE&#xA;     ELSE&#xA;          FOR each vertex v in G DO&#xA;              IF A(G,s,v,d/2) AND A(G,v,t,d/2) THEN&#xA;                   RETURN TRUE&#xA;              ENDIF&#xA;          ENDFOR&#xA;          return FALSE&#xA;END A&#xA;</code></pre>&#xA;&#xA;<p>I tried to prove correctness using invariants, but I'm not sure if that's the best way to prove it. Could you help me, please?</p>&#xA;&#xA;<p>And I tried to obtain time complexity considering the for-loop, but also I have doubts.</p>&#xA;&#xA;<p>Thanks a lot for your help!</p>&#xA;", "<p>I know that this problem is a known NP-Complete problem, but I'm curious as to why a particular algorithm won't work. Given a graph <span class=\"math-container\">$G = (V,E)$</span>, and edge weights <span class=\"math-container\">$w(e)$</span>, why can we not create a new graph <span class=\"math-container\">$G' = (V,E')$</span>, and flip the sign of each edge weight, i.e set the weight of each edge <span class=\"math-container\">$e' \\in E'$</span> to <span class=\"math-container\">$w(e') = 0-w(e)$</span> and use an algorithm such as Bellman-Ford to find the minimum weight path on this new graph. I understand that flipping the sign of the edges could create negative cycles, implying there is no shortest path in <span class=\"math-container\">$G'$</span>, but won't this imply that there is a positive cycle in <span class=\"math-container\">$G$</span>, meaning there is no longest path? Can someone give a counter-example of when this algorithm would fail?</p>&#xA;", "<p>I am looking for a polynomial-time algorithm that takes as input a bipartite graph <span class=\"math-container\">$(X\\cup Y, E)$</span>, and returns one of two options:</p>&#xA;&#xA;<ol>&#xA;<li><p>If a perfect matching exists, it returns the matching;</p></li>&#xA;<li><p>Otherwise, it returns a witness based on Hall's theorem, i.e., a set <span class=\"math-container\">$S\\subseteq X$</span> such that the number of neighbors of <span class=\"math-container\">$S$</span> is smaller than <span class=\"math-container\">$|S|$</span>.</p></li>&#xA;</ol>&#xA;&#xA;<p>I found <a href=\"https://en.wikipedia.org/wiki/Matching_(graph_theory)#In_unweighted_bipartite_graphs\" rel=\"nofollow noreferrer\">in wikipedia</a> various algorithms for finding a maximum matching in an unweighted bipartite graph. Such algorithms can be used to determine if a perfect matching exists. But does any of these algorithms also return an evidence in case of failure?</p>&#xA;&#xA;<p>EDIT: I have read the links in the answer of Yuval Filmus below, but it took me some time to fill in the missing details. For future reference, here is a detailed solution. Below, let <span class=\"math-container\">$n := |X| = |Y|$</span>.</p>&#xA;&#xA;<p><strong>Step 1</strong>. Define a flow network with <span class=\"math-container\">$2n+2$</span> nodes in the following structure:</p>&#xA;&#xA;<p><span class=\"math-container\">$$ s \\rightrightarrows X \\rightrightarrows Y \\rightrightarrows t $$</span> </p>&#xA;&#xA;<p>where:</p>&#xA;&#xA;<ul>&#xA;<li><span class=\"math-container\">$s$</span> is a new source node connected to all vertices in <span class=\"math-container\">$X$</span> with capacity 1;</li>&#xA;<li>every original edge of <span class=\"math-container\">$E$</span> is directed from <span class=\"math-container\">$X$</span> to <span class=\"math-container\">$Y$</span> with capacity <span class=\"math-container\">$\\infty$</span>;</li>&#xA;<li>each vertex in <span class=\"math-container\">$Y$</span> is connected with capacity 1 to a new sink node <span class=\"math-container\">$t$</span>.</li>&#xA;</ul>&#xA;&#xA;<p><strong>Step 2</strong>. Use the <a href=\"https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm\" rel=\"nofollow noreferrer\">Ford-Fulkerson algorithm</a> to find a maximum flow in that graph. Suppose the maximum flow size is <span class=\"math-container\">$m$</span> (which must be at most <span class=\"math-container\">$n$</span>). </p>&#xA;&#xA;<p><strong>Step 3</strong>. If <span class=\"math-container\">$m = n$</span> then we are done - the flow induces a matching of size <span class=\"math-container\">$n$</span> which is perfect.</p>&#xA;&#xA;<p><strong>Step 4</strong>. Otherwise, <span class=\"math-container\">$m &lt; n$</span>.&#xA;The FF algorithm also returns an <em><span class=\"math-container\">$s$</span>-<span class=\"math-container\">$t$</span> minimum cut</em> of size <span class=\"math-container\">$m$</span> - a partition <span class=\"math-container\">$(C,C')$</span> of the vertices in the graph, such that <span class=\"math-container\">$s\\in C$</span>, <span class=\"math-container\">$t\\in C'$</span>, and the sum of capacities of edges directed from <span class=\"math-container\">$C$</span> to <span class=\"math-container\">$C'$</span> is <span class=\"math-container\">$m$</span>.</p>&#xA;&#xA;<p>This cut cannot cross any edge of <span class=\"math-container\">$E$</span>, since these edges have infinite capacity. Hence, the cut size is determined by edges from <span class=\"math-container\">$s$</span> to <span class=\"math-container\">$X\\cap C'$</span> and from <span class=\"math-container\">$Y\\cap C$</span> to <span class=\"math-container\">$t$</span>. So <span class=\"math-container\">$m = |X\\cap C'| + |Y\\cap C| = (n-|X\\cap C|)+|Y\\cap C|$</span>. Hence: <span class=\"math-container\">$|X\\cap C| = |Y\\cap C| + (n-m) &gt; |Y\\cap C|$</span>. Since the cut cannot cross edges of <span class=\"math-container\">$E$</span>, all neighbors of <span class=\"math-container\">$|X\\cap C|$</span> must be in <span class=\"math-container\">$|Y\\cap C|$</span>, so <span class=\"math-container\">$|X\\cap C|$</span> is the desired Hall-violator.</p>&#xA;", "<p>The Bellman-Ford algorithm on a graph with <span class=\"math-container\">$n$</span> vertices, normally includes a loop executed <span class=\"math-container\">$n-1$</span> times. Each time through the loop we iterate over the list of edges <span class=\"math-container\">$(u,v)$</span> and relax <span class=\"math-container\">$v$</span>.  Note that we don't relax <span class=\"math-container\">$u$</span> and <span class=\"math-container\">$v$</span> on each iteration through the edges.</p>&#xA;&#xA;<p>What I don't understand is that if <span class=\"math-container\">$G$</span> is an undirected graph with <span class=\"math-container\">$n$</span> vertices, then it is equivalent to a directed graph with <span class=\"math-container\">$2n$</span> vertices.    We simply think of the edge between <span class=\"math-container\">$u$</span> and <span class=\"math-container\">$v$</span> as a set <span class=\"math-container\">$\\{u,v\\}$</span> for an undirected graph, and as the ordered pair <span class=\"math-container\">$(u,v)$</span> for a directed graph.</p>&#xA;&#xA;<p>I don't understand why the Bellman-Ford algorithm needs only <span class=\"math-container\">$n-1$</span> repetitions for both a directed and undirected graph.  It seems like it should take <span class=\"math-container\">$n-1$</span> repetitions for directed graph, and <span class=\"math-container\">$2n-1$</span> repetitions for undirected graphs or we should relax both vertices of an edge on each iteration.</p>&#xA;&#xA;<p>Otherwise stated, why does running Bellman-Ford on a directed graph, also find the shortest paths of the undirected graphs?</p>&#xA;", "<p>The <a href=\"https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm\" rel=\"noreferrer\">Bellman-Ford algorithm</a> can be used to find a negative cycle in a general graph, in time <span class=\"math-container\">$O(|V||E|)$</span>. Is there a faster algorithm for finding a negative cycle in a bipartite directed graph, where the edges in one direction (from X to Y) are all positive and the edges in the other direction (from Y to X) are all negative?</p>&#xA;&#xA;<hr>&#xA;&#xA;<p>One idea that I considered is to solve two instances of the minimum-weight assignment problem: one with only the edges from X to Y, and one with only the edges from Y to X. Combining the two assignments gives a directed cycle in the original graph. However there are two problems with this idea:</p>&#xA;&#xA;<ul>&#xA;<li>The computational problem of finding a minimum-weight assignment is not necessarily smaller than Bellman-Ford, for example the Hungarian algorithm requires time <span class=\"math-container\">$O(|V|^3)$</span>. </li>&#xA;<li>The directed cycle found in this way is not necessarily minimum-weight in the original graph; it is possible that the original graph has a negative cycle while this algorithm will yield only a positive cycle. For example, consider a graph with four vertices in each side, with the following weights:&#xA;<span class=\"math-container\">\\begin{align*}&#xA;w(x_1\\to y_1) = w(x_2\\to y_2) &amp;= 1&#xA;\\\\&#xA;w(y_2\\to x_1) = w(y_1\\to x_2) &amp;= -2&#xA;\\\\&#xA;w(x_3\\to y_3) = w(x_4\\to y_4) &amp;= 5&#xA;\\\\&#xA;w(y_4\\to x_3) = w(y_3\\to x_4) &amp;= -3&#xA;\\end{align*}</span>&#xA;and all other weights are <span class=\"math-container\">$+\\infty$</span>.</li>&#xA;</ul>&#xA;&#xA;<p>There is a negative cycle <span class=\"math-container\">$x_1\\to y_1\\to x_2\\to y_2$</span> (total weight -2). However, the minimum-weight assignment from X to Y has weight 12 and the  minimum-weight assignment from Y to X has weight -10 so the total is positive.</p>&#xA;", "<p>According to <a href=\"https://stackoverflow.com/a/14804529/6784796\">this</a> answer, the Bellman-Ford algorithm doesn't work when an undirected graph contains negative weight edges since any edge with negative weight forms a negative cycle, and the distances to all vertices in a negative cycle, as well as the distances to the vertices reachable from this cycle,  are not defined. So in the all-pairs shortest path problem, can we say the Floyd\u2013Warshall algorithm also doesn't work on an undirected graph contains negative weight edges for the same reason?</p>&#xA;", "<p>Given a connected, directed graph <span class=\"math-container\">$G=(V,E)$</span>, vertices <span class=\"math-container\">$s,t \\in V$</span> and a coloring, s.t. <span class=\"math-container\">$s$</span> and <span class=\"math-container\">$t$</span> are black and all other vertices are either <strong>red</strong> or <strong>blue</strong>, is it possible to find a simple path from <span class=\"math-container\">$s$</span> to <span class=\"math-container\">$t$</span> with more red than blue vertices in polynomial time?</p>&#xA;&#xA;<p>I think it should be possible but our TA said this was NP-hard.</p>&#xA;&#xA;<p>Idea for a solution:  </p>&#xA;&#xA;<p>From <span class=\"math-container\">$G$</span> create <span class=\"math-container\">$G'=(V',E')$</span> as follows:  </p>&#xA;&#xA;<ul>&#xA;<li><p>Split all <span class=\"math-container\">$v \\in V\\setminus \\{s,t\\}$</span> in two vertices <span class=\"math-container\">$v_{in}$</span> and <span class=\"math-container\">$v_{out}$</span>. <span class=\"math-container\">$V'$</span> is made up of the split vertex pairs and <span class=\"math-container\">$s$</span> and <span class=\"math-container\">$t$</span>.   </p></li>&#xA;<li><p>For all <span class=\"math-container\">$e=(u,v) \\in E$</span> introduce an edge <span class=\"math-container\">$(u_{out},v_{in})$</span>. (For edge <span class=\"math-container\">$(x,v)$</span> or <span class=\"math-container\">$(u,x)$</span> where <span class=\"math-container\">$x \\in \\{s,t\\}$</span> create edge <span class=\"math-container\">$(x,v_{in})$</span> or <span class=\"math-container\">$(u_{out},x)$</span> resp.). Also, introduce an edge <span class=\"math-container\">$(v_{in},v_{out})$</span> for any of the split vertices. So <span class=\"math-container\">$E'$</span> contains two types of edges: the ones that correspond to edges from <span class=\"math-container\">$E$</span> and the ones that correspond to vertices from <span class=\"math-container\">$V$</span>.</p></li>&#xA;</ul>&#xA;&#xA;<p>Now, we introduce weights as follows:  </p>&#xA;&#xA;<ul>&#xA;<li><span class=\"math-container\">$w((v_{in},v_{out})) = -1$</span> if the corresponding vertex <span class=\"math-container\">$v$</span> was <strong>red</strong>.   </li>&#xA;<li><span class=\"math-container\">$w((v_{in},v_{out})) = +1$</span> if the corresponding vertex <span class=\"math-container\">$v$</span> was <strong>blue</strong>.   </li>&#xA;<li><span class=\"math-container\">$w(e) = 0$</span> for all other edges, i.e. the ones that correspond to edges of <span class=\"math-container\">$G$</span> rather than vertices.</li>&#xA;</ul>&#xA;&#xA;<p>Now, conduct an algorithm for shortest paths of your choice like Dijkstra, Bellman-Ford,... , check whether the length of the given path is <span class=\"math-container\">$&lt;0$</span> and you are done.</p>&#xA;&#xA;<p>Why does this not work? Is it because we may have negative cycles? We could detect those with Bellman Ford but then we'd have to find the desired path with non-efficient means rendering this decision problem NP-hard? &#xA;Is there an elegant reduction to show NP-hardness?</p>&#xA;", "<p>In an unweighted graph, we can find Multiple Source Shortest Paths using the Breadth-First Search algorithm by setting the distance of all starting vertices to zero and pushing them into the queue at the beginning of the algorithm. </p>&#xA;&#xA;<p>However, I'm wondering if we can use the same technique to solve Multiple Source Shortest Paths in a weighted graph using Dijkstra's algorithm (for non-negative weight edges) and Bellman-Ford algorithm (when negative weight edges are allowed, and of course there is no queue here).</p>&#xA;&#xA;<p>If I'm right, we can think in this situation as there are edges with weight equal to zero between any source and all other sources in the graph.</p>&#xA;&#xA;<p>So, can we use this technique in a weighted graph? And why?</p>&#xA;", "<p>In a directed graph where the edges may have positive or negative weights, the Bellman-Ford algorithm detects cycles in which the sum of weights is strictly negative (<span class=\"math-container\">$&lt;0$</span>). I need to detect cycles in which the sum of weights is weakly negative (<span class=\"math-container\">$\\leq 0$</span>). Here is my current idea: </p>&#xA;&#xA;<ul>&#xA;<li>For each edge <span class=\"math-container\">$e$</span>, replace the weight <span class=\"math-container\">$w_e$</span> with a vector of length 2, <span class=\"math-container\">$(w_e.-1)$</span>.</li>&#xA;<li>Run Bellman-Ford on the graph with vector weights, where addition of vectors is done elementwise, the zero element is <span class=\"math-container\">$(0,0)$</span>, and comparison is done lexicographically.</li>&#xA;</ul>&#xA;&#xA;<p>Each strictly-negative cycle in the new graph has a weight of <span class=\"math-container\">$(W,k)&lt;(0,0)$</span>, where either <span class=\"math-container\">$W&lt;0$</span>, or <span class=\"math-container\">$W=0$</span> and <span class=\"math-container\">$k&lt;0$</span>. Since <span class=\"math-container\">$k&lt;0$</span> for every cycle, this amounts to <span class=\"math-container\">$W\\leq 0$</span>, so in the original graph it is a weakly-negative cycle.&#xA;Conversely, each weakly-negative cycle in the original graph has a weight of <span class=\"math-container\">$W\\leq 0$</span>, so in the new graph it corresponds to a strictly-negative cycle.</p>&#xA;&#xA;<p>Is this algorithm correct? Is the proof sufficiently accurate?</p>&#xA;", "<p>Does there exist a flow graph that always requires flow to be pushed back no matter what ordering of augmenting paths is chosen in <a href=\"https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm\" rel=\"noreferrer\">Ford Fulkerson</a>?</p>&#xA;&#xA;<p>Let's assume we use the standard procedure of repeating this step:</p>&#xA;&#xA;<ol>&#xA;<li>Find an augmenting path <span class=\"math-container\">$p$</span> in residual graph <span class=\"math-container\">$G_R$</span> of <span class=\"math-container\">$G$</span>.</li>&#xA;<li>Let <span class=\"math-container\">$c$</span> be the minimum capacity edge in <span class=\"math-container\">$p$</span>.</li>&#xA;<li>Increase the flow on every edge in <span class=\"math-container\">$p$</span> by <span class=\"math-container\">$c$</span>.</li>&#xA;<li>Update <span class=\"math-container\">$G_R$</span>.</li>&#xA;</ol>&#xA;&#xA;<p>The key here is step 1, where select augmenting paths. For many graphs, if we had an oracle to tell us which augmenting paths to use, we would never need to push flow back. I'm am curious if there is a case for which, regardless of augmenting paths and their orders, we will <em>always</em> be required to \"push flow back\". To clarify what I mean:</p>&#xA;&#xA;<blockquote>&#xA;  <p>To <em>push flow back</em> in <span class=\"math-container\">$G$</span>, means to increase the flow on an edge <span class=\"math-container\">$(u,v)$</span> in <span class=\"math-container\">$G_R$</span> such that edge <span class=\"math-container\">$(v,u)$</span> exists in <span class=\"math-container\">$G$</span>.</p>&#xA;</blockquote>&#xA;&#xA;<p>If this is not possible, I would also be interested in a proof that such ordering of augmenting paths always exists? If it is possible, does it generalize to any number of nodes <span class=\"math-container\">$n$</span>? This question is alluded at in the ending sentences of <a href=\"https://cs.stackexchange.com/a/52915/68251\">this answer</a>, but provides no proof. </p>&#xA;&#xA;<p>My initial thoughts were that this would be a trivial proof. However, there are many times when the optimal flow along an augmenting path may <em>not</em> be equivalent to its minimum capacity edge. Since (by step 3) we require paths to be filled to their minimum capacity, we cannot easily meet this. My next thought would be that there should exist at least one augmenting path such that its max flow is equivalent to its minimum capacity edge. This is obvious by the <a href=\"https://en.wikipedia.org/wiki/Max-flow_min-cut_theorem\" rel=\"noreferrer\">Max flow min cut Theorem</a>, but I am not sure how this would apply to the proof. With this, we may be able to get an inductive proof that it is always possible, but I am really unsure of this strategy as well. Any help would be appreciated.</p>&#xA;", "<p>I was reading about maximum flow algorithms comparing the efficiency of the different ones. On the <a href=\"https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm\" rel=\"nofollow noreferrer\">Wikipedia Ford-Fulkerson algorithm page</a>, they present the Edmonds-Karp algorithm as the BFS (instead of DFS) variant of Ford-Fulkerson algorithm.</p>&#xA;&#xA;<p>The point is on time complexity, Ford-Fulkerson algorithm has <span class=\"math-container\">$O(|E||f_{max}|)$</span> whereas Edmonds-Karp is presented to run in <span class=\"math-container\">$O(|V||E|^2)$</span>. My main is question is then, how can I decide which of these algorithm is the faster on an arbitrary max-flow problem ?</p>&#xA;&#xA;<p>I feel very unconfortable with the <span class=\"math-container\">$f_{max}$</span> even if I understand it, because determining it is the goal of the algorithm so estimating it is likely to be hard on the very general case. Depending on problem, <span class=\"math-container\">$f_{max}$</span> may be very high with respect to <span class=\"math-container\">$|E|$</span>, even if one can possibly apply a scale factor on all edges.</p>&#xA;&#xA;<p>I also do not understand where the runtime difference comes from. Generally BFS and DFS have the same expected runtime, the difference between them is more on problem dependant space requirement and features like shortest path, topological order...</p>&#xA;", "<p>Given a graph with |V| vertexes and |E| edges, I have to find a negative cycle, if there is one, in a graph.&#xA;The wanted complexity is O(|V|*|E|).</p>&#xA;&#xA;<p>I was thinking about using Bellman-Ford to solve the question doing this:&#xA;Do |V| iterations of Bellman-Ford, If there were no changes on the last iteration, there is no cycle of negative weight in the graph.&#xA;Otherwise take a vertex the distance to which has changed, and go from it via its ancestors until a cycle is found.&#xA;This cycle will be the desired cycle of negative weight.</p>&#xA;&#xA;<p>The problem is, that no start vertex is given, and Bellman-Ford notes wether there is reachable negative cycle via the start vertex or not.&#xA;Assume that if we start from vertex a there won't be negative cycle and if the start vertex was b there will be one.&#xA;So if I choose a as a start vertex I'll miss the negative graph.</p>&#xA;&#xA;<p>How can I solve that?&#xA;I thought about trying all the vertexes as start vertex but it won't be O(|E|*|V|).</p>&#xA;", "<p>What is an intuitive way to think about the convergence of the distance vector routing algorithm?</p>&#xA;&#xA;<p>According to Wikipedia:</p>&#xA;&#xA;<blockquote>&#xA;  <p>Distance-vector routing protocols use the Bellman\u2013Ford algorithm and Ford\u2013Fulkerson algorithm to calculate the best route.</p>&#xA;</blockquote>&#xA;&#xA;<p>I am aware of the Bellman-Ford and Ford-Fulkerson algorithms and have some intuition for how and why they work. Unfortunately, I fail to see how they relate to the asynchronous distributed distance vector algorithm and so I lack intuition about why it converges.</p>&#xA;", "<blockquote>&#xA;  <p>Diameter of a connected, undirected graph is the smallest natural&#xA;  number <em>d</em>, so that between any two vertices of the graph exist path&#xA;  of length at most <em>d</em>.</p>&#xA;  &#xA;  <p>Prove or disprove: in Bellman-Ford is the number of iterations always&#xA;  equal or lower than <em>d</em>.</p>&#xA;</blockquote>&#xA;&#xA;<p>I'm trying to solve this issue. What I tried was sketching a lot of graphs, however I have failed to find a single graph where the number of iterations would be higher than the diameter. </p>&#xA;&#xA;<p>The only graph where the number of iterations wouldn't be &lt;= than diameter would be a graph with negative edges, however I found out that in undirected graph there can't be any negative edges, otherwhere there would be a negative cycle.</p>&#xA;&#xA;<p>So, AFAIK the statement is correct. However, how would I prove such a statement? I don't even know how to start. Thanks for any help</p>&#xA;", "<p>Within the internal logic of a feature I'm working on, I've run into a need for a solution to essentially this problem:</p>&#xA;&#xA;<p><span class=\"math-container\">$S$</span> is a finite union of <span class=\"math-container\">$K \\geq 1$</span> closed intervals,</p>&#xA;&#xA;<p><span class=\"math-container\">$$S = [a_1,b_1] \\cup \\cdots \\cup [a_K,b_K].$$</span></p>&#xA;&#xA;<p>Select <span class=\"math-container\">$N \\geq 2$</span> points <span class=\"math-container\">$x_i \\in S$</span>, maximizing the smallest difference between any pair of points:</p>&#xA;&#xA;<p><span class=\"math-container\">$$\\Delta = \\min_{i \\neq j} |x_i-x_j|.$$</span></p>&#xA;&#xA;<p>In my case, the intervals are already disjoint and sorted (<span class=\"math-container\">$a_1 \\leq b_1 &lt; a_2 \\leq b_2 &lt; \\ldots  &lt; a_K \\leq b_K$</span>), and solutions are only needed for \"small\" cases: <span class=\"math-container\">$K$</span> and <span class=\"math-container\">$N$</span> will both typically be 10 or smaller, and <span class=\"math-container\">$K+N$</span> can never be more than 30.  Since the numbers are small, it's more important to have a simple and maintainable solution than one with the best possible asymptotic computational complexity, though it's probably good to avoid an exponential- or factorial-time solution if reasonable.</p>&#xA;&#xA;<p><strong>What is a straightforward and effective algorithm for this problem, given these limits on the interval and point counts?</strong></p>&#xA;&#xA;<p>I did notice <a href=\"https://cs.stackexchange.com/questions/35341/find-set-of-points-with-maximum-distance-inside-given-intervals\">this existing question</a> about the same problem, but it's asking about asymptotic complexity and about the effects of having overlapping intervals vs. intervals already normalized to disjoint ones. (Also, it currently has no answers.) Since it mentions linear programming, distance constraints, and Bellman-Ford, I looked into those on Wikipedia. But not being very familiar with those topics, I didn't really see how the problem translates into a graph path optimization problem. And I suspect implementing this sort of algorithm might be more complicated than I really need in my case.</p>&#xA;&#xA;<p>I have worked out how to reduce the problem from selecting real/rational values to selecting natural number parameters: If <span class=\"math-container\">$C_i$</span> of the points are to be chosen from interval <span class=\"math-container\">$[a_i,b_i]$</span>, then</p>&#xA;&#xA;<p><span class=\"math-container\">$$\\sum_{i=1}^K C_i = N \\\\&#xA;\\Delta = \\min_{1 \\leq i \\leq j \\leq K} \\frac{b_j-a_i}{-1+\\sum_{\\ell=i}^j C_\\ell},$$</span></p>&#xA;&#xA;<p>ignoring the terms with denominator <span class=\"math-container\">$0$</span> or <span class=\"math-container\">$-1$</span>.  And the point coordinates of a valid solution can be determined from knowing which of the <span class=\"math-container\">${K\\choose 2}$</span> fractions in this <span class=\"math-container\">$\\Delta$</span> expression are exactly equal to <span class=\"math-container\">$\\Delta$</span>.</p>&#xA;&#xA;<p>So the dumbest brute force approach would be to find <span class=\"math-container\">$\\Delta$</span> for each of the <span class=\"math-container\">${{K+N-1}\\choose{N}}$</span> possible partitions of <span class=\"math-container\">$N$</span> into <span class=\"math-container\">$K$</span> ordered buckets. One obvious improvement: <span class=\"math-container\">$a_1$</span> and <span class=\"math-container\">$b_K$</span> can always be two of the selected points. But that's probably way too many possibilities even with <span class=\"math-container\">$N$</span> and <span class=\"math-container\">$K$</span> just around 10.</p>&#xA;&#xA;<p>It seems like some sort of \"divide and conquer\" strategy might be helpful, with splitting the sequence of intervals into two parts, deciding how many points in total to assign to each part, and solving those two subproblems, probably iteratively. But I haven't entirely determined the conditions that would make those subproblems produce valid answers to the larger problem.</p>&#xA;", "<p>The <a href=\"https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm\" rel=\"nofollow noreferrer\">Bellman-Ford algorithm</a> \"can detect and report the negative cycle\", but does it guarantee to find them or it may find some?</p>&#xA;&#xA;<p>The algorithm really focuses on the shortest paths, so I'm unclear if it will find any negative cycle or if it might miss it.</p>&#xA;&#xA;<p>Thanks!</p>&#xA;&#xA;<p>EDIT:&#xA;I'm only interested in knowing if there is a negative cycle (not where it is). How does one prove that Bellman-Ford would find the existence of a cycle?</p>&#xA;", "<p><strong>Problem Statement:</strong></p>&#xA;&#xA;<p>Let <span class=\"math-container\">$G= (V, E)$</span> be a directed graph with costs <span class=\"math-container\">$c_e \\in \\mathbb{R}$</span> on each edge <span class=\"math-container\">$e \\in E$</span>. There are no negative cycles in <span class=\"math-container\">$G$</span>. Suppose there is a sink node <span class=\"math-container\">$t \\in V$</span>, and for each node <span class=\"math-container\">$v \\in V$</span>, there is a label <span class=\"math-container\">$d_v \\in \\mathbb{R}$</span>. Give an algorithm that decides, in linear time, whether it is true that for each <span class=\"math-container\">$v \\in V$</span>, <span class=\"math-container\">$d_v$</span> is the cost of the minimum-cost path from <span class=\"math-container\">$v$</span> to the sink node <span class=\"math-container\">$t$</span>.</p>&#xA;&#xA;<p><strong>Attempt:</strong></p>&#xA;&#xA;<p>The biggest challenge I find is the linear time limitation. The most relevant algorithm to consider here is the Bellman-Ford algorithm, but runs in <span class=\"math-container\">$O(|V|\\,|E|)$</span> time which is too slow, so it requires modifying for this problem.</p>&#xA;&#xA;<p>I have also made an observation: If, for example, <span class=\"math-container\">$(u,v) \\in E$</span> and <span class=\"math-container\">$c_{(u,v)} = 1$</span>, and <span class=\"math-container\">$d_u = 3$</span> and <span class=\"math-container\">$d_v = 5$</span>, then the label <span class=\"math-container\">$d_v$</span> is wrong. This is because passing from <span class=\"math-container\">$v$</span> to <span class=\"math-container\">$u$</span> with a cost of <span class=\"math-container\">$1$</span> and travelling from <span class=\"math-container\">$u$</span> to <span class=\"math-container\">$t$</span> in a minimum cost of <span class=\"math-container\">$3$</span> for a total cost of <span class=\"math-container\">$4$</span> is shorter than the supposed minimum cost from <span class=\"math-container\">$v$</span> to <span class=\"math-container\">$t$</span> given by <span class=\"math-container\">$d_v$</span>, which is <span class=\"math-container\">$5$</span>. I'm not sure if I can use this insight to produce a linear algorithm, but it's the furthest I have gotten so far.</p>&#xA;&#xA;<p><strong>EDIT:</strong></p>&#xA;&#xA;<p>This problem is not a duplicate of the other problem proposed, since the edge weights can be negative in this problem, but the edge weights are positive in the other problem.</p>&#xA;", "<p>The <a href=\"https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm\" rel=\"nofollow noreferrer\">Bellman-Ford Algorithm</a> uses a less-than symbol rather than a less-than-or-equal-to symbol. How does this identify that there is a negative cycle? </p>&#xA;&#xA;<p>For instance, say I have the below example going from initialization state through the first iteration and on to the second.</p>&#xA;&#xA;<p>Initial state</p>&#xA;&#xA;<pre><code>    (0)S----(1)----B(inf)&#xA;        \\         /&#xA;        (1)    (-1)  &#xA;          \\     /&#xA;           \\   / &#xA;             C(inf)&#xA;</code></pre>&#xA;&#xA;<p>First phase</p>&#xA;&#xA;<pre><code>...Check edges...&#xA;S-&gt;B&#xA;D[S] + 1 &lt; D[B] = 0 + 1 &lt; inf =&gt; True =&gt; Update D[B]&#xA;&#xA;B-&gt;C&#xA;D[B] + (-1) &lt; D[C] = 1 + (-1) &lt; inf =&gt; True =&gt; Update D[C]&#xA;&#xA;    (0)S----(1)----B(1)&#xA;        \\         /&#xA;        (1)    (-1)  &#xA;          \\     /&#xA;           \\   / &#xA;             C(0)&#xA;</code></pre>&#xA;&#xA;<p>Second phase when checking for negative cycles</p>&#xA;&#xA;<pre><code>...Check edges...&#xA;...Skipping to check B-&gt;C...&#xA;B-&gt;C&#xA;D[B] + (-1) &lt; D[C] = 1 + (-1) &lt; 0 =&gt; False &#xA;&#xA;&#xA;&#xA;    (0)S----(1)----B(1)&#xA;        \\         /&#xA;        (1)    (-1)  &#xA;          \\     /&#xA;           \\   / &#xA;             C(0)&#xA;</code></pre>&#xA;&#xA;<p>Shouldn't the last check between <code>B-&gt;C</code> be true to detect the negative cycle? i.e. Shouldn't we use less-than-or-equal-to (\u2264) rather than (&lt;)?</p>&#xA;", "<p>I am trying to fully understand the following algorithm from CLRS book:</p>&#xA;&#xA;<p><a href=\"https://i.stack.imgur.com/L8cRG.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/L8cRG.png\" alt=\"enter image description here\"></a>&#xA;<a href=\"https://i.stack.imgur.com/PAYZW.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/PAYZW.png\" alt=\"enter image description here\"></a></p>&#xA;&#xA;<p>I like to think that it works similarly to Bellman-Ford algorithm by relaxing all edges once for every vertex in the graph. Then we repeat the process for every source vertex <span class=\"math-container\">$s \\in V$</span>. But then looking at the three nested loops in <code>EXTEND-SHORTEST-PATHS</code> and the additional loop in <code>SLOW-ALL-PAIRS-SHORTEST-PATHS</code> I am confused what is happening in every loop. The book says that in every iteration of the loop in <code>SLOW-ALL-PAIRS-SHORTEST-PATHS</code> it computes a matrix of size at most <span class=\"math-container\">$m$</span> edges which confuses me even more.</p>&#xA;&#xA;<p>Could someone please explain in simple terms how the algorithm works? Also in line 7 in <code>EXTEND-SHORTEST-PATHS</code> does it mean:&#xA;<span class=\"math-container\">$$l^{'}_{ij} &gt; l_{ik} + w_{kj} \\Rightarrow l^{'}_{ij} = l_{ik} + w_{kj}$$</span>&#xA;or&#xA;<span class=\"math-container\">$$l^{'}_{ij} &gt;= l_{ik} + w_{kj} \\Rightarrow l^{'}_{ij} = l_{ik} + w_{kj}$$</span>&#xA;While there might not be a difference in both of these cases on computing shortest path distances, it does, however, produce different results when computing predecessor-subgraph.</p>&#xA;&#xA;<p>Thanks in advance.</p>&#xA;", "<p>Suppose we had a graph <span class=\"math-container\">$G = (V,E)$</span>. </p>&#xA;&#xA;<p>This graph can also be seen as a <span class=\"math-container\">$4x5$</span> grid graph as shown in the image. </p>&#xA;&#xA;<p>There is a directed edge from <span class=\"math-container\">$v_{i,j} \\rightarrow v_{i,j+1}$</span> for <span class=\"math-container\">$1 \\leq i \\leq n$</span> and <span class=\"math-container\">$1 \\leq j \\leq m-1$</span>. </p>&#xA;&#xA;<p>Similarly, there is a directed edge from <span class=\"math-container\">$v_{i,j} \\rightarrow v_{i+1,j}$</span> for <span class=\"math-container\">$1 \\leq i \\leq n-1$</span> and <span class=\"math-container\">$1 \\leq j \\leq m$</span>. </p>&#xA;&#xA;<p>What is the most efficient algorithm to determine the shortest path from <span class=\"math-container\">$v_{1,1} \\rightarrow v_{n,m}$</span>? My main idea is to use the Bellman-Ford algorithm, but I am clearly not taking advantage of how this graph is laid out. Any guidance would be much appreciated. </p>&#xA;&#xA;<p>EDIT: The edges are weighted and may possibly be negative.</p>&#xA;&#xA;<p><a href=\"https://i.stack.imgur.com/7wq5m.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/7wq5m.png\" alt=\"enter image description here\"></a></p>&#xA;", "<p>Browsing the wikipedia I got to <a href=\"https://en.wikipedia.org/wiki/K_shortest_path_routing\" rel=\"noreferrer\">this page</a> where it is said: </p>&#xA;&#xA;<blockquote>&#xA;  <p>Finding k shortest paths is possible by extending Dijkstra algorithm or Bellman-Ford algorithm and extend them to find more than one path.</p>&#xA;</blockquote>&#xA;&#xA;<p>The same statement is somewhat repeated in the <a href=\"https://www.algorithmhalloffame.org/algorithms/k-shortest-path-routing/\" rel=\"noreferrer\">hall of fame of algorithms</a>: </p>&#xA;&#xA;<blockquote>&#xA;  <p>To find the shortest path one can use shortest path algorithms such as Dijkstra\u2019s algorithm or Bellman Ford algorithm and extend them to find more than one path</p>&#xA;</blockquote>&#xA;&#xA;<p>Then, the Wikipedia (i.e., the first link, not the second) goes into proving how it is possible to extend Dijkstra's algorithm to solve the loopy variant (i.e., where non-simple paths are allowed). The extension is absolutely simple as it simply consists of allowing each node to be expanded up to <span class=\"math-container\">$k$</span> times, with <span class=\"math-container\">$k$</span> the number of paths to find to the goal state. This idea, indeed, was generalized by Rina Dechter to consider heuristics as well:</p>&#xA;&#xA;<ul>&#xA;<li>Rina Decther, Natalia Flerova and Radu Marinescu. <a href=\"http://www.aaai.org/ocs/index.php/AAAI/AAAI12/paper/viewFile/5167/5349\" rel=\"noreferrer\">Search algorithms for <span class=\"math-container\">$m$</span> best solutions for Graphical Models</a>. AAAI 20, pp. 1895--1901</li>&#xA;<li>Natalia Flerova, Radu Marinescu and Rina Dechter. <a href=\"http://www.jair.org/media/4985/live-4985-9241-jair.pdf\" rel=\"noreferrer\">Search algorithms for the <span class=\"math-container\">$m$</span> best solutions in Graphical Models</a>. Journal of Artificial Intelligence Research (55) 2016, pp. 889--952. </li>&#xA;</ul>&#xA;&#xA;<p>However, I never heard of any extension of Bellman-Ford for solving neither the loopy nor the loopless variants of the <span class=\"math-container\">$k$</span> shortest path routing problem. Moreover, I'm not aware of any algorithm that can solve this problem in the presence of negative edge costs. </p>&#xA;&#xA;<p>The only variant I can think of for extending Bellman-Ford is observing that upon termination the cost of the optimal path of one designated vertex to all the other vertices <span class=\"math-container\">$v\\in V$</span>, <span class=\"math-container\">$d_v$</span>, is known so that one could run sort of a Recursive Best-First Search to enumerate all paths. Maybe is this what the authors of those pages mean?</p>&#xA;&#xA;<p>Thus, my questions are:</p>&#xA;&#xA;<ol>&#xA;<li>What is the way to extend Bellman-Ford to solve the <span class=\"math-container\">$k$</span> shortest path routing problem?</li>&#xA;<li>Are there any algorithms out there for solving the <span class=\"math-container\">$k$</span> shortest path routing problem with negative edge costs (provided there are no negative cycles)? Note that neither Eppstein's nor Yen's algorithm can deal with negative edge costs.</li>&#xA;</ol>&#xA;&#xA;<p>This is all I know about the subject and please note that my questions are a result of my ignorance so that I would be very grateful if any answer is provided or any link I could follow.</p>&#xA;&#xA;<p>Cheers,</p>&#xA;", "<p>Typing out negative weight cycle again and again is kind of annoying, so for the rest of the question I'm going to abbreviate it to NWC.</p>&#xA;&#xA;<p>I'm writing an optimized version of Bellman-Ford's Shortest Path Algorithm on a directed, weighted graph. When I give it a regular graph with no NWC's, it works fine, and finds the answer correctly. But when I give it a NWC, it loops forever. So, I put a system into the implementation where it finds out if there is a NWC, which it does correctly, but now I'm stuck on what to do once I find it. </p>&#xA;&#xA;<p>My first thought was to just go on regularly while setting every vertex in the cycle to negative infinity, but every single vertex after that becomes negative infinity too, and soon enough, a huge chunk of the graph becomes negative infinity and I'm getting bugs left and right because I'm subtracting to negative infinity, adding to negative infinity, while also setting the distance to negative infinity. I technically could fix all the bugs, but then lot's of valuable information on the other vertices is lost because of one little NWC. </p>&#xA;&#xA;<p>My next thought was to just terminate the program, but then again lot's of information is lost on the other vertices. </p>&#xA;&#xA;<p>So,  what is the correct action to be taken when you find a NWC?</p>&#xA;", "<p>I'm solving a problem:</p>&#xA;&#xA;<blockquote>&#xA;  <p>Given a directed, weighted graph <span class=\"math-container\">$G$</span> that has <span class=\"math-container\">$V$</span> vertices (vertex <span class=\"math-container\">$0$</span>, vertex <span class=\"math-container\">$1$</span>, ... ,  vertex <span class=\"math-container\">$(V - 1)$</span>) and <span class=\"math-container\">$E$</span> edges and a positive integer <span class=\"math-container\">$m$</span>, describe an algorithm that finds the length of the shortest path from vertex <span class=\"math-container\">$0$</span> to vertex <span class=\"math-container\">$(V - 1)$</span> using less than or equal to <span class=\"math-container\">$m$</span> edges. Note that the graph may contain negative cycles. If there is no such path, print \"N\" for that case.</p>&#xA;</blockquote>&#xA;&#xA;<p>First, I tried Bellman-Ford algorithm, but I cannot deal with negative cycles. Next, I tried one using recursive DFS, but it takes too much time! I think dynamic programming may solve this problem, but I don't know how to start with DP. Is there any fancy way to solve this problem in short time?</p>&#xA;", "<p>I've read there are ways you can determine all reachable pairs using Strongly Connected Components. But, I want to calculate all reachable nodes on the fly - so I don't have to store a massive reachability matrix in RAM. What sort of time complexity would be possible for an algorithm to calculate all reachable nodes in a directed graph, from a single node?</p>&#xA;&#xA;<p><a href=\"https://i.stack.imgur.com/SLpaw.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/SLpaw.png\" alt=\"enter image description here\"></a></p>&#xA;&#xA;<p>Here's a naive algorithm I came up with, I'm not sure of the time complexity of this. <span class=\"math-container\">$O(V!)$</span>?</p>&#xA;&#xA;<p>It seems to have an <span class=\"math-container\">$O(V)$</span> spacial complexity though.</p>&#xA;&#xA;<p>I've read about the Bellman-Ford algorithm with a time complexity of <span class=\"math-container\">$O(EV)$</span> which is essentially <span class=\"math-container\">$O(V^3)$</span> and the Floyd-Warshall algorithm which is <span class=\"math-container\">$O(V^3)$</span>. They require <span class=\"math-container\">$O(V)$</span> and <span class=\"math-container\">$O(V^2)$</span> space complexity, respectively.</p>&#xA;&#xA;<p>The problem is only inputs can be determined in constant time. So, one would have to find (in <span class=\"math-container\">$O(V)$</span> time)  all outputs for a particular node. What I actually did in my solution is invert the graph using a similar technique, before running DFS. But I don't know if this is optimal... Also, due to a copy of the graph being stored in memory, my solution has a spacial complexity worse than the bellman-ford algorithm. If this time complexity is also worse, I may as well use bellman fords algorithm</p>&#xA;", "<p>I recently started studying algorithms on my own using Cormen and MIT algo videos in YouTube. I am going thru Bellman-Ford. </p>&#xA;&#xA;<p><a href=\"https://i.stack.imgur.com/PIy2u.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/PIy2u.png\" alt=\"enter image description here\"></a></p>&#xA;&#xA;<p>I have 2 doubts about the correctness of the algorithm:</p>&#xA;&#xA;<ol>&#xA;<li><p>Why are we relaxing (num of vertices - 1) times all the edges? Why not some finite number of times till earlier values and new values remain same?</p></li>&#xA;<li><p>The second for loop (lines 5,6,7 in algo image) is for detecting negative edge cycles. Then I have gone through this correctness. I have seen a theorem that if there is a negative edge cycle reachable from source s then we can find an edge uv such that d(v)>d(u)+w(u,v) [I understood the proof by contradiction (if summing all vertices of negative edge cycle results in sum of all weights along negative cycle positive which means contradiction as it must be negative - page 2 of <a href=\"https://web.stanford.edu/class/archive/cs/cs161/cs161.1168/lecture14.pdf]\" rel=\"nofollow noreferrer\">https://web.stanford.edu/class/archive/cs/cs161/cs161.1168/lecture14.pdf]</a></p></li>&#xA;</ol>&#xA;&#xA;<p>But I am not able to visualise such an edge if I have some negative edge cycle from source vertex s. Please help me: how can such an edge exist?</p>&#xA;&#xA;<p><a href=\"https://i.stack.imgur.com/jnPUW.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/jnPUW.png\" alt=\"enter image description here\"></a></p>&#xA;", "<p>While proving the correctness of the Bellman-Ford algorithm, we prove the following lemma:</p>&#xA;&#xA;<blockquote>&#xA;  <p>After k (k >= 0) iterations of relaxations, for any node&#xA;  <strong>u</strong> that has at least one path from <strong>s</strong> (the start node) to <strong>u</strong> with at most <strong>k</strong> edges, the distance of from <strong>s</strong> to <strong>u</strong> is the smallest length of a path&#xA;  from <strong>s</strong> to <strong>u</strong> that contains at most <strong>k</strong> edges.</p>&#xA;</blockquote>&#xA;&#xA;<p>We prove this lemma using mathematical induction as follows:</p>&#xA;&#xA;<ol>&#xA;<li>Base case: After 0 iteration, all distance values are <strong>infinity</strong>,&#xA;but for <strong>s</strong> the distance is <strong>0</strong>, which is correct!</li>&#xA;<li>We assume the lemma is true for <strong>k</strong> iterations and now we have to prove it for <strong>k+1</strong> iterations!</li>&#xA;<li>Before <strong>k + 1</strong>th iteration, dist[u] (which is the distance of <strong>u</strong>, from <strong>s</strong>) is the smallest length of a path from <strong>s</strong> to <strong>u</strong> containing at most <strong>k</strong> edges. Each path from <strong>s</strong> to <strong>u</strong> goes through one of the incoming edges <strong>(v, u)</strong>. Relaxing by <strong>(v, u)</strong> is comparing it with the smallest length of a path from <strong>s</strong> to <strong>u</strong> through <strong>v</strong> containing at most <strong>k + 1</strong> edges -- this proves it!</li>&#xA;</ol>&#xA;&#xA;<p>Now, I have doubt in the 3rd point. Let us say that in the <strong>k+1</strong>-th iteration the node <strong>u</strong> has got a new distance after some edge relaxations, now according to the above lemma, this distance must be the shortest of the distances of all the paths with at most <strong>k+1</strong> edges from <strong>s</strong> to <strong>u</strong>. Now, consider another node <strong>w</strong>, that has an edge to it, from <strong>u</strong>. Now, the length of the path form <strong>s</strong> to <strong>w</strong> via <strong>v</strong> will have at most <strong>k+2</strong> edges, but if this edge is relaxed to reduce the dist[w], then in <strong>k+1</strong>-th iteration itself, we will have included a path (to <strong>w</strong>) that has almost <strong>k+2</strong> edges right? Is it not a contradiction? Can it not happen? </p>&#xA;&#xA;<p>To be more precise I am unable to reason the fact that, the lemma holds true throughout the <strong>k+1</strong>-th iteration -- I am not convinced with the 3rd step of the proof.</p>&#xA;&#xA;<p>If someone can explain to me the 3rd step or whole proof more clearly, it would be really helpful! If someone can share a proof that does not use mathematical induction will also be really helpful!</p>&#xA;", "<p>I can use Bellman-Ford to get some of the elementary negative weight cycles in a graph. It's not guaranteed to always get all of them.</p>&#xA;<p>(Elementary Cycle: A cycle is elementary if no vertex but the first and last appears twice.)</p>&#xA;<p>But I want to find <em>ALL</em> elementary negative weight cycles. Even taking each vertex as the source will not always get <em>ALL</em> negative weight cycles.</p>&#xA;<p>Take this graph for example:</p>&#xA;<p><a href=\"https://i.stack.imgur.com/mjDew.jpg\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/mjDew.jpg\" alt=\"enter image description here\" /></a></p>&#xA;<p>With Bellman-Ford, starting from any vertex, I can only get one cycle &quot;U\u2192H\u2192U&quot;.</p>&#xA;<p>The cycle &quot;U\u2192S\u2192U&quot; is always missing.</p>&#xA;<p>Is there any algorithm with which I can find all negative weight cycles reliably?</p>&#xA;", "<p>I am trying to understand the Bellman-Ford algorithm from Jon Kleinberg, \u00c9va Tardos: *[Algorithm\u2007Design].&#xA;Page no: 296 The recursive equation that is written:&#xA;<span class=\"math-container\">$$M[v]= \\min(M[v], \\min_{w\\in V}&#xA;(c_{vw} + M[w]).$$</span></p>&#xA;<p>I am not getting how this equation is correct?<br />&#xA;Because in the book it is written that <span class=\"math-container\">$M[v]$</span> is the shortest path from <span class=\"math-container\">$v-t$</span>,<br />&#xA;but shouldn't <span class=\"math-container\">$M[v]$</span> be the shortest path from <span class=\"math-container\">$s-v$</span> using at most <span class=\"math-container\">$i-1$</span> edges?</p>&#xA;", "<p>I have read that if we run the outer-loop of the Bellman-Ford algorithm for |V| times (where |V| is the number of nodes in the graph) and check if any distance has changed in the |V|th iteration (i.e. the last iteration) then there exists at least one negative weight cycle in the graph. But why does this work? Why only run for |V| times, why not more than that?</p>&#xA;<ol>&#xA;<li><p>I am looking for a <strong>mathematical proof</strong> on why a change in the value of the distance of a node during the last iteration (|V|th iteration) implies that there is a negative weight cycle?</p>&#xA;</li>&#xA;<li><p>Can we detect all the nodes that are either reachable or are parts of the negative weight cycles <strong>after the |V|th iteration</strong> (can this also be <strong>proved</strong> <strong>mathematically</strong>)?</p>&#xA;</li>&#xA;</ol>&#xA;<p>It would be helpful if someone can either provide the proofs and explanations or direct to the relevant resources.</p>&#xA;<p>Thank you.</p>&#xA;", "<p>I'm working on my research and I found that for directed graphs, there are many algorithms trying to solve shortest path problem(like Dijkstra, Bellman\u2010Ford algorithm), but few is to get all paths(including circles) in the result. Is it because the complexity is way too expensive? Thanks in advance for your help!</p>&#xA;", "<p>I need to prove that for every given graph, that doesn't contain negative cycles, there is an order of edges so that Bellman-Ford algorithm will finish running after one iteration.</p>&#xA;<p>I could only solve it to graphs that are DAGs using topological sort, but couldn't find a way proving it for every graph.</p>&#xA;", "<p>I'm trying to find an efficient algorithm (running time of O(|V|*|E|)) that finds for any graph an order of the edges that allows Bellman-Ford algorithm to run in a single sweep (iteration).</p>&#xA;<p>I was thinking of running some known algorithm that will find the shortest path tree of the given graph and then running Bellman-Ford algorithm on that tree, but I'm not sure if it works.</p>&#xA;", "<p>The Bellman-Ford algorithm checks all edges in each step, and if for each edge the following:&#xA;<span class=\"math-container\">$d(v)&gt;d(u)+w(u,v)$</span>&#xA;holds, then <span class=\"math-container\">$d(v)$</span> will be updated. <span class=\"math-container\">$w(u,v)$</span> is the weight of edge <span class=\"math-container\">$(u, v)$</span> and <span class=\"math-container\">$d(u)$</span> is the length of best path was found for vertex <span class=\"math-container\">$u$</span>.</p>&#xA;<p>If in any step there is no update for all vertexes, the algorithms terminate.</p>&#xA;<p>If Bellman-Ford will be used for finding all shortest paths from vertex <span class=\"math-container\">$s$</span> in graph <span class=\"math-container\">$G$</span> with <span class=\"math-container\">$n$</span> vertex, terminate after <span class=\"math-container\">$k &lt; n$</span> iteration then following is True:</p>&#xA;<pre><code>number of edges in all shortest paths from <span class=\"math-container\">$s$</span> is at most <span class=\"math-container\">$k-1$</span>&#xA;</code></pre>&#xA;<p><strong>I think some times this is true and sometimes is false (when we check all edges simultaneously... maybe this is wrong), but I need a clear definition for the above sentence or a small example about logic.</strong>  <strong>I need verification of the above fact. is it always true? why?</strong></p>&#xA;<p>New Updates:</p>&#xA;<p>The above statement is dependent on the implementation of your algorithm (at least I think).</p>&#xA;<p>Which implementation makes it true and under which condition it becomes false...</p>&#xA;<p>I see 4 version of Belman Ford on <a href=\"http://31.42.184.140/main/2439000/bee4c250b5a62c352658d58f91b8dd39/Erickson%2C%20Jeff%20-%20Algorithms%20%282019%29.pdf\" rel=\"nofollow noreferrer\">This Jeff Erricson Algorithm Book on Page 295</a>.</p>&#xA;", "<p>I read in my notes:</p>&#xA;<blockquote>&#xA;<p>If we use Dijkstra <span class=\"math-container\">$|V|$</span> times (<span class=\"math-container\">$|V|$</span> number of vertices) for finding <strong>all-pairs shortest paths</strong> in graph <span class=\"math-container\">$G$</span>, we get time complexity for Dijkstra algorithm as <span class=\"math-container\">$O(VE+ V^2 \\log V)$</span>, and if we run Bellman\u2013Ford algorithm <span class=\"math-container\">$|V|$</span> times, we get time <span class=\"math-container\">$O(V^2E)$</span>.</p>&#xA;</blockquote>&#xA;<p>The above details are not important.</p>&#xA;<p>I read too, that Dijkstra's algorithm works better for sparse graph, that is, <span class=\"math-container\">$O(VE+ V^2 \\log V)$</span> is better than <span class=\"math-container\">$O(V^2E)$</span> asymptotically for sparse graphs.</p>&#xA;<p>I think sparse graphs are graphs satisfying <span class=\"math-container\">$ |E| = O(V)$</span>  or <span class=\"math-container\">$E=o(V^2/\\log V)$</span>. In fact, I have two misunderstandings:</p>&#xA;<ol>&#xA;<li><p>Which one is more common as the definition of a sparse graph?</p>&#xA;</li>&#xA;<li><p>According to 1, how we can intuitively understand that <span class=\"math-container\">$O(VE+ V^2 \\log V)$</span> is better asymptotically than <span class=\"math-container\">$O(V^2E)$</span>? At least I think the reverse is true.</p>&#xA;</li>&#xA;</ol>&#xA;", "<p>TLDR: I want to know if there's a simple way to fill in distances for all vertices <em>reachable</em> from negative weight cycles (not just ones on the cycle itself) once Bellman-Ford has found a negative-weight cycle.</p>&#xA;<p>The Bellman-Ford algorithm finds single-source shortest distances <span class=\"math-container\">$d$</span> for a graph of <span class=\"math-container\">$|V|$</span> vertices by making <span class=\"math-container\">$|V|-1$</span> passes through all <span class=\"math-container\">$|E|$</span> edges with weights <span class=\"math-container\">$w$</span>, and then checking each edge <span class=\"math-container\">$u \\rightarrow v$</span>, with weight <span class=\"math-container\">$w(u,v)$</span>, for negative-weight cycles. If <span class=\"math-container\">$v.d &gt; u.d + w(u,v)$</span>, then we know that there exists a negative weight cycle consisting of some path from <span class=\"math-container\">$v$</span> to <span class=\"math-container\">$u$</span>, then the edge <span class=\"math-container\">$(u,v)$</span>. <a href=\"https://cs.stackexchange.com/a/133732/82288\">It's straightforward to find every vertex <strong>on</strong> that cycle</a> and set all their <span class=\"math-container\">$d$</span> to <span class=\"math-container\">$-\\infty$</span>.</p>&#xA;<p>However, this also must mean that any vertices <strong>reachable</strong> from but not <strong>on</strong> this cycle must also have <span class=\"math-container\">$d = -\\infty$</span>. One way to update all their distances is to collapse each cycle to a vertex and then perform DFS from each such &quot;cycle vertex&quot;, setting <span class=\"math-container\">$x.d = -\\infty$</span> for every reachable vertex <span class=\"math-container\">$x$</span>.</p>&#xA;<p>I'm wondering if there's a faster way to update all the distances, involving perhaps a smaller modification to Bellman-Ford?</p>&#xA;", "<p>CLRS exercise 24.4-9 says the following:</p>&#xA;<blockquote>&#xA;<p>Show that the Bellman-Ford algorithm, when run on the constraint graph for a system <span class=\"math-container\">$Ax \\leq b$</span> of difference constraints, minimizes the quantity <span class=\"math-container\">$\\max_i\\{x_i\\} - \\min_i\\{x_i\\}$</span> subject to <span class=\"math-container\">$Ax \\leq b$</span>. Explain how this fact might come in handy if the algorithm is used to schedule construction jobs.</p>&#xA;</blockquote>&#xA;<p>I understand how to prove the result, but I'm having trouble imagining how to map these <span class=\"math-container\">$x_i$</span> to quantities in scheduling, like &quot;job begin time&quot;, &quot;job end time&quot;, &quot;job duration&quot;, &quot;cost&quot;, etc. I've seen several places claim that this can be used to minimize &quot;makespan&quot;, i.e. total duration of a schedule of jobs, but I don't see the connection.</p>&#xA;<p>In Chapter 24 of the book, constraints <span class=\"math-container\">$x_k - x_j \\leq b$</span>, with <span class=\"math-container\">$j,k\\geq 1$</span> are converted into vertices <span class=\"math-container\">$(v_j, v_k)$</span> with weight <span class=\"math-container\">$b$</span>. A source vertex <span class=\"math-container\">$v_0$</span> is added, with zero-weight edges going to all <span class=\"math-container\">$v_1, v_2 \\ldots v_n$</span>, so Bellman-Ford gives the solution <span class=\"math-container\">$x_i = \\delta(v_0, v_i)$</span>, that is, the most negative path from <span class=\"math-container\">$v_0$</span> to <span class=\"math-container\">$v_i$</span>.</p>&#xA;<p>Superficially, it sounds right to just say &quot;<span class=\"math-container\">$x_i$</span> are the completion times, so if you minimize the difference between the earliest and the latest, that minimizes the total or cost you spend working&quot;.</p>&#xA;<p>However, if <span class=\"math-container\">$x_i$</span> is &quot;the completion time for job <span class=\"math-container\">$i$</span> or something like that, what would be the significance of a constraint like <span class=\"math-container\">$x_i - x_j \\leq b$</span>? &quot;Job <span class=\"math-container\">$i$</span> must be finished at at most <span class=\"math-container\">$b$</span> hours after job <span class=\"math-container\">$j$</span>&quot;? That sounds somewhat contrived and unrealistic. What's a more natural mapping of these <span class=\"math-container\">$x_i$</span> to scheduling concepts?</p>&#xA;", "<h2>Context</h2>&#xA;<p>This question is related to <a href=\"https://cs.stackexchange.com/questions/102574/max-weight-path-in-a-graph\">the fact one can't use Bellman-Ford</a> to find max weight paths in directed graphs with cycles. The reason is that giving a new graph <span class=\"math-container\">$\\tilde{G}$</span> with negative weights (e.g. <span class=\"math-container\">$\\tilde{w}_{ij} = - w_{ij}$</span>) will result in cycles with negative sum, thus no minimum cost walk exists in <span class=\"math-container\">$\\tilde{G}$</span>.</p>&#xA;<h2>General question</h2>&#xA;<p>How well can we approximate the maximum weight path between <span class=\"math-container\">$i$</span> and <span class=\"math-container\">$j$</span> in <span class=\"math-container\">$G$</span>, using the shortest path algorithm on a graph <span class=\"math-container\">$\\tilde{G}$</span> with transformed weights <span class=\"math-container\">$\\tilde{w}_{ij}$</span> ?&#xA;In my case, one has <span class=\"math-container\">$w_{ij}\\in\\mathbb{N}\\setminus\\{0\\}$</span>. The transformed weights <span class=\"math-container\">$\\tilde{w}_{ij}$</span> can be obtained using any function, but I assume a decreasing function <span class=\"math-container\">$f$</span> is well adapted so that <span class=\"math-container\">$w &lt; w' \\iff f(w) &gt; f(w')$</span>.</p>&#xA;<h2>My approach</h2>&#xA;<p>I am currently trying to use <span class=\"math-container\">$f(w) = \\dfrac{1}{w}$</span>, in this context we have two important paths given a fixed path length <span class=\"math-container\">$L$</span>.</p>&#xA;<p>Denote a path <span class=\"math-container\">$p = (i_0i_1, i_1i_2, i_2i_3, \\dots i_{L-1}i_L$</span>) with weights <span class=\"math-container\">$W = (w^{(1)}, w^{(2)}, w^{(3)}, \\dots, w^{(L)})$</span>,</p>&#xA;<p>denote the maximum weight path of length <span class=\"math-container\">$L$</span> by <span class=\"math-container\">$p^*$</span> with weights <span class=\"math-container\">$W^*$</span> achieving&#xA;<span class=\"math-container\">$$ W^* = \\arg\\max_W\\{\\mathtt{Cost}(W)\\} = \\arg\\max_W \\sum_{k=1}^L w^{(k)}$$</span>&#xA;and the path <span class=\"math-container\">$p_*$</span> achieving minimum transformed cost with weights <span class=\"math-container\">$W_*$</span>&#xA;<span class=\"math-container\">$$ W_* = \\arg\\min_W \\sum_{k=1}^L \\tilde{w}^{(k)} = \\arg\\min_W \\sum_{k=1}^L f(w^{(k)}) = \\arg\\min_W \\sum_{k=1}^L \\dfrac{1}{w^{(k)}}$$</span></p>&#xA;<h2>Specific question</h2>&#xA;<p>In this specific context, do we have the approximation <span class=\"math-container\">$\\mathtt{Cost}(W^*) \\approx \\mathtt{Cost}(W_*)$</span> ?</p>&#xA;<p>Or is it &quot;very wrong&quot; to replace <span class=\"math-container\">$W^*$</span> by <span class=\"math-container\">$W_*$</span> ? What would be the distribution of the <strong>relative error</strong> defined as&#xA;<span class=\"math-container\">$$E_r = \\dfrac{\\lvert\\mathtt{Cost}(W^*) - \\mathtt{Cost}(W_*)\\rvert}{\\mathtt{Cost}(W^*)}$$</span></p>&#xA;<h2>Statistical analysis</h2>&#xA;<p>I have tried a quick statistical analysis as follows:</p>&#xA;<ul>&#xA;<li>Letting <span class=\"math-container\">$L\\in\\{3,4,5,6,7,8\\}$</span></li>&#xA;<li>sampling <span class=\"math-container\">$w \\sim \\mathrm{Uniform}(1,w_{\\max})$</span></li>&#xA;<li>The value for <span class=\"math-container\">$w_{\\max}$</span> was also picked from the set <span class=\"math-container\">$\\{50, 100, 150, 200, 500\\}$</span></li>&#xA;<li>for each combination of <span class=\"math-container\">$L,w_{\\max}$</span> I computed <span class=\"math-container\">$10^5$</span> values of <span class=\"math-container\">$W^*, W_*$</span> using <span class=\"math-container\">$10^3$</span> candidate weights <span class=\"math-container\">$W_i$</span></li>&#xA;</ul>&#xA;<p><strong>The results:</strong></p>&#xA;<ul>&#xA;<li>In <span class=\"math-container\">$80.8\\%$</span> of cases we have <span class=\"math-container\">$\\mathtt{Cost}(W^*) = \\mathtt{Cost}(W_*)$</span> and even better <span class=\"math-container\">$W^*=W_*$</span></li>&#xA;<li>When computing the <strong>relative error</strong> <span class=\"math-container\">$E_r$</span> one finds that <span class=\"math-container\">$82.6\\%$</span> of error values are less than <span class=\"math-container\">$0.001$</span>, <span class=\"math-container\">$89.7\\%$</span> less than <span class=\"math-container\">$0.01$</span> and <span class=\"math-container\">$99.9\\%$</span> less than <span class=\"math-container\">$0.1$</span></li>&#xA;</ul>&#xA;<p>The histogram for <span class=\"math-container\">$E_r &gt; 0$</span> is as follows</p>&#xA;<p><a href=\"https://i.stack.imgur.com/gci51.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/gci51.png\" alt=\"relative_error distribution\" /></a></p>&#xA;", "<p>I have created a function that generates a complete, directed, and weighted graph, represented in an adjacency matrix but most Bellman-Ford implementations use an adjacency list. Is it even possible to use an adjacency matrix for Bellman-Ford without increasing significant time complexity? What would be the simplest way to use my graph-generating algorithm to the Bellman-Ford algorithm? Am I required to convert my matrix into a list?</p>&#xA;", "<p>I need to plan an algorithm that decides if a directed weighted graph <span class=\"math-container\">$G = (V,E)$</span>  has a zero weight cycle.</p>&#xA;<ul>&#xA;<li><p>the graph has no negtive cycles</p>&#xA;</li>&#xA;<li><p>the algorithm needs to be in <span class=\"math-container\">$O(|V| \\cdot |E|)$</span> time</p>&#xA;</li>&#xA;</ul>&#xA;<hr />&#xA;<p>my idea was to first add a vertex (called <span class=\"math-container\">$r$</span>) and connect it to all of the vertices in the graph.&#xA;and then use the Bellman-Ford algorithm in some kind of way from <span class=\"math-container\">$r$</span>.&#xA;but I can't figure out how to change the algorithm in that kind of way to find a zero weighted cycle.</p>&#xA;", "<p>I am given a directed graph <span class=\"math-container\">$G=(V, E)$</span> with a weight function <span class=\"math-container\">$w: E\\to\\mathbb{R}$</span>, that doesn't contain negative cycles.</p>&#xA;<p>I need to find an algorithm that returns <code>true</code> if and only if there is a cycle with weight zero in the graph.</p>&#xA;<p>The time complexity needs to be <span class=\"math-container\">$O(|V||E|)$</span>, so I thought about using Bellman-Ford algorithm, but I have two problems with that:</p>&#xA;<p>First, the graph doesn't necessarily connected, so I can't pick an arbitrary source vertex for the algorithm.</p>&#xA;<p>Second, I can't figure out how the algorithm can help me, and what I can do with its output.</p>&#xA;<p>I know that a <a href=\"https://cs.stackexchange.com/questions/28897/bellman-ford-and-zero-distance-cycle\">similar question</a> have been asked, but the answer just suggests to run Bellman-Ford algorithm, but as I mentioned, I can't choose a source vertex. In addition, I don't understand why the suggested answer will work at all.</p>&#xA;", "<p>I understand that the Bellman-Ford Algorithm can solve the single-source shortest-paths problem. However, can it also be used to determine the longest path in an undirected, graph through first negating the weight of all the edges?</p>&#xA;", "<p>I am trying to understand the following exercise from Introduction to algorithm (3rd edtion).</p>&#xA;<blockquote>&#xA;<p>Exercise 24.1-3 (page 654)</p>&#xA;<p>Given a weighted, directed graph <span class=\"math-container\">$G=(V, E)$</span> with no negative-weight cycles, let <span class=\"math-container\">$m$</span> be the maximum over all vertices <span class=\"math-container\">$v \\in V$</span> of the minimum number of edges in a shortest path from source <span class=\"math-container\">$s$</span> to <span class=\"math-container\">$v$</span>. (Here, the shortest path is by weight, not the number of&#xA;edges.) Suggest a simple change to the Bellman-Ford algorithm that&#xA;allows it to terminate in <span class=\"math-container\">$m + 1$</span> passes, even if <span class=\"math-container\">$m$</span> is not known in&#xA;advances.</p>&#xA;</blockquote>&#xA;<p>So what is <span class=\"math-container\">$m$</span> exactly? I am really have the trouble to understand the first sentence.</p>&#xA;", "<p>The following corollary can be found at page 653 of &quot;Introduction to algorithms (3rd edition)&quot;</p>&#xA;<blockquote>&#xA;<p>Corollary 24.3</p>&#xA;<p>Let <span class=\"math-container\">$G = (V, E)$</span> be a weighted, directed graph with source vertex <span class=\"math-container\">$s$</span>&#xA;and a weight function <span class=\"math-container\">$w: E \\to \\mathbb{R}$</span>. Then, for each vertex <span class=\"math-container\">$v&#xA;&gt; \\in V$</span>, there is a path from <span class=\"math-container\">$s$</span> to <span class=\"math-container\">$v$</span> if and only if BELLMAN-FORD&#xA;terminates with <span class=\"math-container\">$v.d &lt; \\infty$</span> when it is run on <span class=\"math-container\">$G$</span>.</p>&#xA;</blockquote>&#xA;<p>I have an intuition for the corollary and would formulate its proof as following:</p>&#xA;<p><span class=\"math-container\">$\\rightarrow$</span>: Suppose there are paths from <span class=\"math-container\">$s$</span> to <span class=\"math-container\">$v$</span>, we call the shortest path <span class=\"math-container\">$p$</span>. The path <span class=\"math-container\">$p$</span> is shortest and therefore simple and hence has at most <span class=\"math-container\">$|V| - 1$</span> edges. Each edge of the path <span class=\"math-container\">$p$</span> will be relaxed by Bellman-Ford, an operation which will only decrease <span class=\"math-container\">$v.d$</span>. Therefore we can concluse, that <span class=\"math-container\">$v.d &lt; \\infty$</span> after the algorithm terminates.</p>&#xA;<p>Another argument may also include the &quot;Path-relaxation property&quot;, which states <span class=\"math-container\">$v.d = \\delta(s, v) &lt; \\infty$</span> after relaxations of all edges of <span class=\"math-container\">$p$</span>.</p>&#xA;<p><span class=\"math-container\">$\\leftarrow$</span>: Suppose there is no path from <span class=\"math-container\">$s$</span> to <span class=\"math-container\">$v$</span> but Bellman-Ford terminates with <span class=\"math-container\">$v.d &lt; \\infty$</span>. This would be a contradiction with &quot;No-path property&quot;, which states <span class=\"math-container\">$v.d = \\delta(s, v) = \\infty$</span>.</p>&#xA;<p>I am self-studying the book and there is a lack of feedbacks from tutor, so my question is: would my proof be sufficient in this case?</p>&#xA;", "<p>We recently learned Bellman-Ford algorithm for shortest path in class, but I didn't understand it.&#xA;Can you give me intuition for why the algorithm works? And can you please explain why it is correct? Why are we sure to find negative circles?</p>&#xA;<p>Also, we learned the following two lemmas:</p>&#xA;<blockquote>&#xA;<p><strong>Lemma (upper bound property)</strong>: At all times we have that for all <span class=\"math-container\">$v$</span>, <span class=\"math-container\">$v.d \\ge \\delta(s,v)$</span>.</p>&#xA;</blockquote>&#xA;<blockquote>&#xA;<p><strong>Lemma (Path-relaxation property)</strong>: Let <span class=\"math-container\">$p = \\langle s=v_1, v_2, \\ldots, v_n \\rangle$</span>. Following any sequence of relaxations in which the edges <span class=\"math-container\">$(v_1,v_2),(v_2,v_3),\\ldots,(v_{k-1},v_k)$</span> are relaxed in order, we have that <span class=\"math-container\">$v_k.d \\le w(p)$</span>.</p>&#xA;</blockquote>&#xA;<p>Here:</p>&#xA;<ul>&#xA;<li><p><span class=\"math-container\">$v.d$</span> is the distance of <span class=\"math-container\">$v$</span> from the initial vertex <span class=\"math-container\">$s$</span>. (We constantly update this value using the relax function in the Bellman\u2013Ford algorithm.)</p>&#xA;</li>&#xA;<li><p><span class=\"math-container\">$\\delta(s,v)$</span> is the minimum weight path between <span class=\"math-container\">$s$</span> and <span class=\"math-container\">$v$</span>.</p>&#xA;</li>&#xA;<li><p><span class=\"math-container\">$w(p)$</span> is the total weight of path <span class=\"math-container\">$p$</span>.</p>&#xA;</li>&#xA;</ul>&#xA;<p>Can you give me an intuition for the lemmas and what they mean?</p>&#xA;", "<p>I am working on <a href=\"https://courses.csail.mit.edu/6.006/fall11/psets/ps6.pdf\" rel=\"nofollow noreferrer\">Problem 6-1 from MIT's Fall 2011 6.006 course</a>. The problem reads as:</p>&#xA;<blockquote>&#xA;<p>Problem 6-1. [30 points] I Can Haz Moar Frendz?</p>&#xA;</blockquote>&#xA;<blockquote>&#xA;<p>Alyssa P. Hacker is interning at RenBook (\u4eba\u4e66 / \u4eba\u66f8 in Chinese), a burgeoning social network&#xA;website. She needs to implement a new friend suggestion feature. For two friends <code>u</code> and <code>v</code> (friendship is undirected), the <em><strong>EdgeRank</strong></em> <code>ER(u, v)</code> can be computed in constant time based on the interest&#xA;<code>u</code> shows in <code>v</code> (for example, how frequently <code>u</code> views <code>v</code>\u2019s profile or comments on <code>v</code>\u2019s wall). Assume&#xA;that EdgeRank is directional and asymmetric, and that its value falls in the range (0, 1). A user&#xA;<code>u</code> is <em><strong>connected</strong></em> to a user <code>v</code> if they are connected through some mutual friends, i.e., <span class=\"math-container\">$u = u_0$</span> has a&#xA;friend <span class=\"math-container\">$u_1$</span>, who has a friend <span class=\"math-container\">$u_2$</span>, . . . , who has a friend <span class=\"math-container\">$u_k = v$</span>. The integer <code>k</code> is the <em><strong>vagueness</strong></em> of the&#xA;connection. Define the <em><strong>strength</strong></em> of such a connection to be&#xA;<span class=\"math-container\">$$S(p) = \\prod_{i=1}^kER(u_{i\u22121}, u_i)$$</span>&#xA;For a given user <code>s</code>, Alyssa wants to have a way to rank potential friend suggestions according to&#xA;the strength of the connections <code>s</code> has with them. In addition, the vagueness of those connections&#xA;should not be more than <code>k</code>, a value Alyssa will decide later.</p>&#xA;</blockquote>&#xA;<blockquote>&#xA;<p>Help Alyssa by designing an algorithm that computes the <strong>strength</strong> of the strongest connection&#xA;between a given user <code>s</code> and <strong>every other user</strong> <code>v</code> to whom <code>s</code> is connected with vagueness at most&#xA;<code>k</code>, in <code>O(kE + V)</code> time (i.e., for every pair of <code>s</code> and <code>v</code> for <code>v \u2208 V\\{s}</code>, compute the strength of the&#xA;strongest connection between them with vagueness at most <code>k</code>). Assume that the network has <code>|V|</code>&#xA;users and <code>|E|</code> friend pairs. Analyze the running time of your algorithm. For partial credit, give a&#xA;slower but correct algorithm. You can describe your algorithm in words, pseudocode or both.</p>&#xA;</blockquote>&#xA;<p>After reading the problem, the first intuition I got is to:</p>&#xA;<ul>&#xA;<li>Do a BFS from the source node <code>s</code> and stop the BFS as soon as <code>k</code>th level is reached.</li>&#xA;<li>And, while doing the BFS, calculate and maintain the strength that each node encountered has with <code>s</code></li>&#xA;<li>At the end, when the BFS stops after the <code>k</code> levels, we iterate the strengths stored, and find the one with maximum value.</li>&#xA;</ul>&#xA;<p>Here is the (pseudo/Python)code for the same:</p>&#xA;<pre><code>def find_strongest_connection(graph, source_node, k):&#xA;    nodes_discovered = deque()&#xA;&#xA;    # source is already discovered&#xA;    strengths = {source_node: 1}&#xA;    parents, levels = {source_node: None}, {source_node: 0}&#xA;    nodes_discovered.append(source_node)&#xA;&#xA;    while nodes_discovered:&#xA;        parent_node = nodes_discovered.popleft()&#xA;    &#xA;        current_level = levels[parent_node] + 1&#xA;        if current_level &gt; k:&#xA;            break&#xA;    &#xA;        for current_node in graph.adj[parent_node]:&#xA;            if current_node not in levels:&#xA;                # current_node is now discovered&#xA;                strengths[current_node] = strengths[parent_node] * ER(parent_node, current_node)&#xA;                parents[current_node], levels[current_node] = parent_node, current_level&#xA;                nodes_discovered.append(current_node)&#xA;            &#xA;    strongest_connection, max_strength = None, -1&#xA;    for connection, strength in strengths.items():&#xA;        if strength &gt; max_strength:&#xA;            max_strength = strength&#xA;            strongest_connection = connection&#xA;&#xA;    return strongest_connection, max_strength&#xA;</code></pre>&#xA;<p>To me, this solution looks correct. But when I was going through the <a href=\"https://courses.csail.mit.edu/6.006/fall11/psets/ps6_solutions.pdf\" rel=\"nofollow noreferrer\">solutions provided by MIT for the problem set</a>, I see they are first transforming the graph, and then applying the Bellman-Ford's algorithm. What I want to know is that am I missing something really basic in my understanding of the problem and the algorithm that I have come up with?</p>&#xA;<p>I am asking this because seeing the complex solution provided in the solution set is making me doubt my overly simple solution. Unfortunately, I cannot think of a case, where my solution would fail. If there is any issue with my algorithm, any hint would be much much appreciated.</p>&#xA;<p>PS: I am not a student looking for an answer to my homework. I am a full time working professional.</p>&#xA;", "<p>It may be unlikely that anyone knows this but I have a specific question about Freebase.  Here is the Freebase page from the <a href=\"http://www.freebase.com/m/014_d3\" rel=\"nofollow\">Ford Taurus automotive model</a> .  It has a property called \"Related Models\".  Does anyone know how this list of related models was compiled.  What is the similarity measure that they use?  I don't think it is only about other wikipedia pages that link to or from this page.  Alternatively, it may be that this is user generated.  Does anyone know for sure?</p>&#xA;", "<p>I have huge car photos.</p>&#xA;&#xA;<p>I want to predict car's <strong>\"brand-model-body type and production year\"</strong></p>&#xA;&#xA;<p><a href=\"https://i.stack.imgur.com/5IcrM.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/5IcrM.png\" alt=\"data\"></a></p>&#xA;&#xA;<p>First, I splitted data into train and validation, and I categorized them like this.</p>&#xA;&#xA;<p><a href=\"https://i.stack.imgur.com/Tqlvy.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/Tqlvy.png\" alt=\"categorized_cars\"></a></p>&#xA;&#xA;<p>Every category has about 1000 train and 900 validation images.</p>&#xA;&#xA;<p>My plan was: I train my keras model with these categories after training, model can predict labels like below:</p>&#xA;&#xA;<p>audi a3 sedan 2008  => %25</p>&#xA;&#xA;<p>audi a3 sedan 2009  => %25</p>&#xA;&#xA;<p>audi a3 sedan 2010  => %25</p>&#xA;&#xA;<p>audi a3 sedan 2011  => %25</p>&#xA;&#xA;<p>And I can tell user that: <strong>\"This car is Audi A3 Sedan 2008-2011\"</strong></p>&#xA;&#xA;<p>My problem is, some of these categories have very similar photos. For example: audi a3 2009 and audi a3 2010 have same body type and there is not much difference between photos (No difference in reality). &#xA;Because of that, train accuracy has improved to about 0.9 but validation accuracy hasn't improved above 0.55</p>&#xA;&#xA;<p>When I try some predictions, it usually gives same label, <strong>\"Ford Focus sedan 2009\"</strong> :)</p>&#xA;&#xA;<p>Here is my output:</p>&#xA;&#xA;<pre><code>epoch,          acc,              loss,              val_acc,       val_loss&#xA;27,    0.7965514530544776, 0.56618134500483, 0.5192149643316993, 1.729015349846447&#xA;&#xA;28,    0.8058803490480816, 0.5408204138258657, 0.5176764522193236, 1.778763979018732&#xA;&#xA;29,    0.8167710489770164, 0.5116128672937693, 0.523258489762041, 1.7806432932022545&#xA;&#xA;30,    0.8256544639818643, 0.4872381848016096, 0.5207534764479939, 1.8059904007678271&#xA;&#xA;31,    0.8355546238309248, 0.4629556378035959, 0.5237253032663666, 1.8191414148756815&#xA;&#xA;32,    0.8424464767701014, 0.4444190686917562, 0.5242512903147193, 1.8496954914466912&#xA;&#xA;33,    0.8508739288802705, 0.422022156655134, 0.5303593149032422, 1.8565427863780883&#xA;&#xA;34,    0.8576819265745635, 0.40545297008116027, 0.5262894901236571, 1.909881308499735&#xA;</code></pre>&#xA;&#xA;<p>My train code is here:</p>&#xA;&#xA;<pre><code>Image_width, Image_height = 224, 224&#xA;num_epoch = 5000&#xA;batch_size = 16&#xA;learning_rate = 0.0001&#xA;model = ResNet50(weights='imagenet', include_top=False, input_shape=(Image_width, Image_height, 3))&#xA;fc_neuron_count = 1024&#xA;output = model.output&#xA;output = GlobalAveragePooling2D()(output)&#xA;output = Dense(fc_neuron_count, activation='relu')(output)&#xA;predictions = Dense(num_classes, activation='softmax')(output)&#xA;model = Model(inputs=model.input, outputs=predictions)&#xA;&#xA;model.compile(optimizer=opt.Adam(lr=learning_rate), loss=losses.categorical_crossentropy,&#xA;              metrics=['accuracy'])&#xA;&#xA;history_transfer_learning = model.fit_generator(&#xA;    train_generator,&#xA;    epochs=num_epoch,&#xA;    steps_per_epoch=num_train_samples // batch_size,&#xA;    validation_data=validation_generator,&#xA;    validation_steps=num_validate_samples // batch_size,&#xA;    class_weight='auto',&#xA;    callbacks=callbacks_list)&#xA;</code></pre>&#xA;&#xA;<ul>&#xA;<li><p>Am I doing something wrong? How can I achieve this result?</p></li>&#xA;<li><p>Should I change validation accuracy calculation, or should I give more photos per category?</p></li>&#xA;</ul>&#xA;", "<p>I am trying to classify cars for a towing company. Junky  cars earn more when  sent to the junkyard, and the more valuable cars should earn more at the auction, despite the auction fee.  Creating a logistic regression that takes into account Make, Model, Mileage,  Year and Run status helps us improve the accuracy of which cars should go where, but a difficulty arises: Sometimes, a car that would be classified as junk can actually be an outlier, and sell for a lot of money. So to optimize our model, <strong>we don't really care that much whether we are right or wrong on an individual car, so much as we maximize our bottom line</strong>.</p>&#xA;<p>All of the models I have seen (Logistic regression, RF, linear regression) make predictions on a line by line basis.&#xA;What would be a good model to try and maximize the aggregate sum of the predictions?</p>&#xA;<p>Below is a reprex of my data, as well as basic code I used.&#xA;What I actually tried until now is to look at past data, and classify, in hindsight, what should have been done, based on prices that were earned in the auction vs available junk prices.  I then ran a glm against that classification to predict the future. As mentioned above, my code improved the accuracy of our decisions, and would have sent more cars to junk correctly, but  some  that we classified as junk sold for so much in the auction that  it wasn't worth sending <em>any</em> to junk.</p>&#xA;<p>What is the proper way to approach this?</p>&#xA;<pre class=\"lang-r prettyprint-override\"><code>cars &lt;- structure(list(YearOfCar = c(2009L, 2009L, 2003L, 2004L),  &#xA;    Make = c(&quot;Hyundai&quot;, &quot;Lexus&quot;, &quot;Ford&quot;, &quot;Toyota&quot;), Model = &#xA;    c(&quot;Sonata&quot;, &quot;GS 350&quot;, &quot;F-250 Super Duty&quot;,&quot;Camry&quot;), PickUpState = &#xA;    c(&quot;MN&quot;, &quot;LA&quot;, &quot;MA&quot;, &quot;NJ&quot;), Auction_Result = c(650,625,425, 1500), &#xA;    Auction_Fee = c(144.25, 373.54, 213.5, 187), Mileage = c(116120L, &#xA;    198900L, 140241L, 312927L), Runs = structure(c(1L, 1L, 1L, 2L), &#xA;    .Label = c(&quot;No&quot;, &quot;Yes&quot;), class = &quot;factor&quot;),   junkyard_Offer = &#xA;    c(230L, 235L, 140L, 300L), Date = structure(c(17592,  17707, &#xA;    17674, 17583), class = &quot;Date&quot;)), row.names = 3:6, class = &#xA;    &quot;data.frame&quot;)&#xA;cars$hindsight &lt;- ifelse(cars$Auction_Result- &#xA;    cars$Auction_Fee&gt;cars$junkyard_Offer,1,0)&#xA;glmodel &lt;- glm(hindsight~Make+Model+Mileage+Runs, data = cars, &#xA;    family=&quot;binomial&quot;)&#xA;prediction &lt;- predict(glmodel, cars, type = 'response')&#xA;prediction_classifier &lt;-  if_else(prediction&gt;.501,1,0)&#xA;cars$prediction_results &lt;- ifelse(prediction_classifier==1, &#xA;    cars$Auction_Result-cars$Auction_Fee,cars$junkyard_Offer)&#xA;</code></pre>&#xA;", "<p>In a 1976 debate with Governor Jimmy Carter, (sitting) President Gerald Ford (in)famously said, \"Eastern Europe is not under Soviet domination.\"</p>&#xA;&#xA;<p><a href=\"http://www.time.com/time/specials/packages/article/0,28804,1844704_1844706_1844449,00.html\" rel=\"nofollow noreferrer\">http://www.time.com/time/specials/packages/article/0,28804,1844704_1844706_1844449,00.html</a></p>&#xA;&#xA;<p>The questioner, Max Frankel gave Ford a chance to correct himself but Ford declined to do so, reiterating his earlier statement. One of my former (eastern European-American) bosses said, \"That's when Ford lost my vote.\"</p>&#xA;&#xA;<p>Ford lost Ohio by about 5,000 popular votes. Move Ohio and one other state from the Carter column to the Ford column, and Ford would have won the election (at least in the electoral college).</p>&#xA;&#xA;<p>Have many other \"famous\" (world-renowned) politicians lost a close election after failing to correct a critical error in a speech when given the chance to do so?</p>&#xA;", "<p>A study from the <a href=\"http://usatoday30.usatoday.com/news/nation/story/2012-04-26/imiigrant-civics-test-americans-fail/54563612/1?fullsite=true\" rel=\"noreferrer\">Center for the Study of the American Dream</a> at Xavier University in Cincinnati found that 35% of native born citizens couldn't pass a civics test.</p>&#xA;<blockquote>&#xA;<p>Immigrants applying for U.S. citizenship have to pass a 10-question civics test asking basic questions about American history and government, and about 93% succeed.</p>&#xA;<p>But <strong>only 65% of native-born Americans could get the required six out of 10</strong> right answers when asked the same questions in a telephone poll. [...]</p>&#xA;<p>Ford noted that 44% of those with a high school education or less passed the test, rising to 82% among college grads.</p>&#xA;</blockquote>&#xA;<p><strong>Have any states proposed bills (or have enacted laws) to require a prospective voter to pass a civics test before voting since the Voting Rights Act of 1965?</strong> (if so, which bill?)</p>&#xA;", "<p>There are a lot of Americans who wear MAGA hats. Theoretically, if President Trump were impeached, I wonder if they would continue to wear them? Would Trump go down like Robert E. Lee, losing, but maintaining the faithful base of devotees due to a hero? Or would they stop supporting him, and conveniently forget their prior support, sort of like how everyone today hates Kevin Spacey? (That is a rhetorical question; please do not endeavor to answer it.)</p>&#xA;&#xA;<p>Consistent with this line of inquiry, I would like to know the following: What happened after Nixon? When he resigned, did the voters forget him and spit on his memory and move on? Or was he remembered fondly, even immediately afterward?</p>&#xA;&#xA;<p><em>Please do not answer by debating whether Trump deserves to be or will be impeached. This is not an appropriate forum for that debate. My question is about the Nixon-Ford era, and is best answered from historical record, or from an American citizen who is old enough to remember.</em></p>&#xA;"]